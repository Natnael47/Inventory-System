
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model WithdrawalLog
 * 
 */
export type WithdrawalLog = $Result.DefaultSelection<Prisma.$WithdrawalLogPayload>
/**
 * Model InventoryPurchase
 * 
 */
export type InventoryPurchase = $Result.DefaultSelection<Prisma.$InventoryPurchasePayload>
/**
 * Model StockBatch
 * 
 */
export type StockBatch = $Result.DefaultSelection<Prisma.$StockBatchPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model WorkLog
 * 
 */
export type WorkLog = $Result.DefaultSelection<Prisma.$WorkLogPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Inventories
 * const inventories = await prisma.inventory.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Inventories
   * const inventories = await prisma.inventory.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.withdrawalLog`: Exposes CRUD operations for the **WithdrawalLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WithdrawalLogs
    * const withdrawalLogs = await prisma.withdrawalLog.findMany()
    * ```
    */
  get withdrawalLog(): Prisma.WithdrawalLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryPurchase`: Exposes CRUD operations for the **InventoryPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryPurchases
    * const inventoryPurchases = await prisma.inventoryPurchase.findMany()
    * ```
    */
  get inventoryPurchase(): Prisma.InventoryPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockBatch`: Exposes CRUD operations for the **StockBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockBatches
    * const stockBatches = await prisma.stockBatch.findMany()
    * ```
    */
  get stockBatch(): Prisma.StockBatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workLog`: Exposes CRUD operations for the **WorkLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkLogs
    * const workLogs = await prisma.workLog.findMany()
    * ```
    */
  get workLog(): Prisma.WorkLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Inventory: 'Inventory',
    WithdrawalLog: 'WithdrawalLog',
    InventoryPurchase: 'InventoryPurchase',
    StockBatch: 'StockBatch',
    Supplier: 'Supplier',
    Employee: 'Employee',
    WorkLog: 'WorkLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "inventory" | "withdrawalLog" | "inventoryPurchase" | "stockBatch" | "supplier" | "employee" | "workLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      WithdrawalLog: {
        payload: Prisma.$WithdrawalLogPayload<ExtArgs>
        fields: Prisma.WithdrawalLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WithdrawalLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WithdrawalLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalLogPayload>
          }
          findFirst: {
            args: Prisma.WithdrawalLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WithdrawalLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalLogPayload>
          }
          findMany: {
            args: Prisma.WithdrawalLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalLogPayload>[]
          }
          create: {
            args: Prisma.WithdrawalLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalLogPayload>
          }
          createMany: {
            args: Prisma.WithdrawalLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WithdrawalLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalLogPayload>
          }
          update: {
            args: Prisma.WithdrawalLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalLogPayload>
          }
          deleteMany: {
            args: Prisma.WithdrawalLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WithdrawalLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WithdrawalLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WithdrawalLogPayload>
          }
          aggregate: {
            args: Prisma.WithdrawalLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWithdrawalLog>
          }
          groupBy: {
            args: Prisma.WithdrawalLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WithdrawalLogCountArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalLogCountAggregateOutputType> | number
          }
        }
      }
      InventoryPurchase: {
        payload: Prisma.$InventoryPurchasePayload<ExtArgs>
        fields: Prisma.InventoryPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPurchasePayload>
          }
          findFirst: {
            args: Prisma.InventoryPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPurchasePayload>
          }
          findMany: {
            args: Prisma.InventoryPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPurchasePayload>[]
          }
          create: {
            args: Prisma.InventoryPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPurchasePayload>
          }
          createMany: {
            args: Prisma.InventoryPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPurchasePayload>
          }
          update: {
            args: Prisma.InventoryPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPurchasePayload>
          }
          deleteMany: {
            args: Prisma.InventoryPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPurchasePayload>
          }
          aggregate: {
            args: Prisma.InventoryPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryPurchase>
          }
          groupBy: {
            args: Prisma.InventoryPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryPurchaseCountAggregateOutputType> | number
          }
        }
      }
      StockBatch: {
        payload: Prisma.$StockBatchPayload<ExtArgs>
        fields: Prisma.StockBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBatchPayload>
          }
          findFirst: {
            args: Prisma.StockBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBatchPayload>
          }
          findMany: {
            args: Prisma.StockBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBatchPayload>[]
          }
          create: {
            args: Prisma.StockBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBatchPayload>
          }
          createMany: {
            args: Prisma.StockBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBatchPayload>
          }
          update: {
            args: Prisma.StockBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBatchPayload>
          }
          deleteMany: {
            args: Prisma.StockBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockBatchPayload>
          }
          aggregate: {
            args: Prisma.StockBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockBatch>
          }
          groupBy: {
            args: Prisma.StockBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockBatchCountArgs<ExtArgs>
            result: $Utils.Optional<StockBatchCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      WorkLog: {
        payload: Prisma.$WorkLogPayload<ExtArgs>
        fields: Prisma.WorkLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkLogPayload>
          }
          findFirst: {
            args: Prisma.WorkLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkLogPayload>
          }
          findMany: {
            args: Prisma.WorkLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkLogPayload>[]
          }
          create: {
            args: Prisma.WorkLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkLogPayload>
          }
          createMany: {
            args: Prisma.WorkLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkLogPayload>
          }
          update: {
            args: Prisma.WorkLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkLogPayload>
          }
          deleteMany: {
            args: Prisma.WorkLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkLogPayload>
          }
          aggregate: {
            args: Prisma.WorkLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkLog>
          }
          groupBy: {
            args: Prisma.WorkLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkLogCountArgs<ExtArgs>
            result: $Utils.Optional<WorkLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    inventory?: InventoryOmit
    withdrawalLog?: WithdrawalLogOmit
    inventoryPurchase?: InventoryPurchaseOmit
    stockBatch?: StockBatchOmit
    supplier?: SupplierOmit
    employee?: EmployeeOmit
    workLog?: WorkLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type InventoryCountOutputType
   */

  export type InventoryCountOutputType = {
    Inventory_Purchases: number
    Withdrawal_Logs: number
    Stock_Batches: number
  }

  export type InventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inventory_Purchases?: boolean | InventoryCountOutputTypeCountInventory_PurchasesArgs
    Withdrawal_Logs?: boolean | InventoryCountOutputTypeCountWithdrawal_LogsArgs
    Stock_Batches?: boolean | InventoryCountOutputTypeCountStock_BatchesArgs
  }

  // Custom InputTypes
  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     */
    select?: InventoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountInventory_PurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryPurchaseWhereInput
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountWithdrawal_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalLogWhereInput
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountStock_BatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockBatchWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    Supplied_Products: number
    Supplied_Stock_Batches: number
    Supplied_Purchases: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Supplied_Products?: boolean | SupplierCountOutputTypeCountSupplied_ProductsArgs
    Supplied_Stock_Batches?: boolean | SupplierCountOutputTypeCountSupplied_Stock_BatchesArgs
    Supplied_Purchases?: boolean | SupplierCountOutputTypeCountSupplied_PurchasesArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountSupplied_ProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountSupplied_Stock_BatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockBatchWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountSupplied_PurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryPurchaseWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    Inventory_Packages: number
    Withdrawal_Logs: number
    Work_Logs: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inventory_Packages?: boolean | EmployeeCountOutputTypeCountInventory_PackagesArgs
    Withdrawal_Logs?: boolean | EmployeeCountOutputTypeCountWithdrawal_LogsArgs
    Work_Logs?: boolean | EmployeeCountOutputTypeCountWork_LogsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountInventory_PackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryPurchaseWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWithdrawal_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalLogWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWork_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    Inventory_Id: number | null
    Stock_Quantity: number | null
    Reorder_Threshold: number | null
    Total_Value: number | null
    Unit_Price: number | null
    Initial_Stock_Quantity: number | null
    Supplier_Id: number | null
  }

  export type InventorySumAggregateOutputType = {
    Inventory_Id: number | null
    Stock_Quantity: number | null
    Reorder_Threshold: number | null
    Total_Value: number | null
    Unit_Price: number | null
    Initial_Stock_Quantity: number | null
    Supplier_Id: number | null
  }

  export type InventoryMinAggregateOutputType = {
    Inventory_Id: number | null
    Product_Name: string | null
    Product_Category: string | null
    Product_Description: string | null
    Is_Discontinued: boolean | null
    Stock_Quantity: number | null
    Reorder_Threshold: number | null
    Total_Value: number | null
    Unit_Of_Measurement: string | null
    Unit_Price: number | null
    Stock_Status: string | null
    Storage_Location: string | null
    Expiry_Date: Date | null
    Initial_Stock_Quantity: number | null
    Supplier_Id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    Inventory_Id: number | null
    Product_Name: string | null
    Product_Category: string | null
    Product_Description: string | null
    Is_Discontinued: boolean | null
    Stock_Quantity: number | null
    Reorder_Threshold: number | null
    Total_Value: number | null
    Unit_Of_Measurement: string | null
    Unit_Price: number | null
    Stock_Status: string | null
    Storage_Location: string | null
    Expiry_Date: Date | null
    Initial_Stock_Quantity: number | null
    Supplier_Id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    Inventory_Id: number
    Product_Name: number
    Product_Category: number
    Product_Description: number
    Is_Discontinued: number
    Stock_Quantity: number
    Reorder_Threshold: number
    Total_Value: number
    Unit_Of_Measurement: number
    Unit_Price: number
    Stock_Status: number
    Storage_Location: number
    Expiry_Date: number
    Initial_Stock_Quantity: number
    Supplier_Id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    Inventory_Id?: true
    Stock_Quantity?: true
    Reorder_Threshold?: true
    Total_Value?: true
    Unit_Price?: true
    Initial_Stock_Quantity?: true
    Supplier_Id?: true
  }

  export type InventorySumAggregateInputType = {
    Inventory_Id?: true
    Stock_Quantity?: true
    Reorder_Threshold?: true
    Total_Value?: true
    Unit_Price?: true
    Initial_Stock_Quantity?: true
    Supplier_Id?: true
  }

  export type InventoryMinAggregateInputType = {
    Inventory_Id?: true
    Product_Name?: true
    Product_Category?: true
    Product_Description?: true
    Is_Discontinued?: true
    Stock_Quantity?: true
    Reorder_Threshold?: true
    Total_Value?: true
    Unit_Of_Measurement?: true
    Unit_Price?: true
    Stock_Status?: true
    Storage_Location?: true
    Expiry_Date?: true
    Initial_Stock_Quantity?: true
    Supplier_Id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    Inventory_Id?: true
    Product_Name?: true
    Product_Category?: true
    Product_Description?: true
    Is_Discontinued?: true
    Stock_Quantity?: true
    Reorder_Threshold?: true
    Total_Value?: true
    Unit_Of_Measurement?: true
    Unit_Price?: true
    Stock_Status?: true
    Storage_Location?: true
    Expiry_Date?: true
    Initial_Stock_Quantity?: true
    Supplier_Id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    Inventory_Id?: true
    Product_Name?: true
    Product_Category?: true
    Product_Description?: true
    Is_Discontinued?: true
    Stock_Quantity?: true
    Reorder_Threshold?: true
    Total_Value?: true
    Unit_Of_Measurement?: true
    Unit_Price?: true
    Stock_Status?: true
    Storage_Location?: true
    Expiry_Date?: true
    Initial_Stock_Quantity?: true
    Supplier_Id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    Inventory_Id: number
    Product_Name: string
    Product_Category: string
    Product_Description: string | null
    Is_Discontinued: boolean
    Stock_Quantity: number
    Reorder_Threshold: number | null
    Total_Value: number | null
    Unit_Of_Measurement: string
    Unit_Price: number | null
    Stock_Status: string | null
    Storage_Location: string | null
    Expiry_Date: Date | null
    Initial_Stock_Quantity: number | null
    Supplier_Id: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Inventory_Id?: boolean
    Product_Name?: boolean
    Product_Category?: boolean
    Product_Description?: boolean
    Is_Discontinued?: boolean
    Stock_Quantity?: boolean
    Reorder_Threshold?: boolean
    Total_Value?: boolean
    Unit_Of_Measurement?: boolean
    Unit_Price?: boolean
    Stock_Status?: boolean
    Storage_Location?: boolean
    Expiry_Date?: boolean
    Initial_Stock_Quantity?: boolean
    Supplier_Id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Supplier?: boolean | Inventory$SupplierArgs<ExtArgs>
    Inventory_Purchases?: boolean | Inventory$Inventory_PurchasesArgs<ExtArgs>
    Withdrawal_Logs?: boolean | Inventory$Withdrawal_LogsArgs<ExtArgs>
    Stock_Batches?: boolean | Inventory$Stock_BatchesArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>



  export type InventorySelectScalar = {
    Inventory_Id?: boolean
    Product_Name?: boolean
    Product_Category?: boolean
    Product_Description?: boolean
    Is_Discontinued?: boolean
    Stock_Quantity?: boolean
    Reorder_Threshold?: boolean
    Total_Value?: boolean
    Unit_Of_Measurement?: boolean
    Unit_Price?: boolean
    Stock_Status?: boolean
    Storage_Location?: boolean
    Expiry_Date?: boolean
    Initial_Stock_Quantity?: boolean
    Supplier_Id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Inventory_Id" | "Product_Name" | "Product_Category" | "Product_Description" | "Is_Discontinued" | "Stock_Quantity" | "Reorder_Threshold" | "Total_Value" | "Unit_Of_Measurement" | "Unit_Price" | "Stock_Status" | "Storage_Location" | "Expiry_Date" | "Initial_Stock_Quantity" | "Supplier_Id" | "createdAt" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Supplier?: boolean | Inventory$SupplierArgs<ExtArgs>
    Inventory_Purchases?: boolean | Inventory$Inventory_PurchasesArgs<ExtArgs>
    Withdrawal_Logs?: boolean | Inventory$Withdrawal_LogsArgs<ExtArgs>
    Stock_Batches?: boolean | Inventory$Stock_BatchesArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      Supplier: Prisma.$SupplierPayload<ExtArgs> | null
      Inventory_Purchases: Prisma.$InventoryPurchasePayload<ExtArgs>[]
      Withdrawal_Logs: Prisma.$WithdrawalLogPayload<ExtArgs>[]
      Stock_Batches: Prisma.$StockBatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Inventory_Id: number
      Product_Name: string
      Product_Category: string
      Product_Description: string | null
      Is_Discontinued: boolean
      Stock_Quantity: number
      Reorder_Threshold: number | null
      Total_Value: number | null
      Unit_Of_Measurement: string
      Unit_Price: number | null
      Stock_Status: string | null
      Storage_Location: string | null
      Expiry_Date: Date | null
      Initial_Stock_Quantity: number | null
      Supplier_Id: number | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `Inventory_Id`
     * const inventoryWithInventory_IdOnly = await prisma.inventory.findMany({ select: { Inventory_Id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Supplier<T extends Inventory$SupplierArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$SupplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Inventory_Purchases<T extends Inventory$Inventory_PurchasesArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$Inventory_PurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Withdrawal_Logs<T extends Inventory$Withdrawal_LogsArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$Withdrawal_LogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Stock_Batches<T extends Inventory$Stock_BatchesArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$Stock_BatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */ 
  interface InventoryFieldRefs {
    readonly Inventory_Id: FieldRef<"Inventory", 'Int'>
    readonly Product_Name: FieldRef<"Inventory", 'String'>
    readonly Product_Category: FieldRef<"Inventory", 'String'>
    readonly Product_Description: FieldRef<"Inventory", 'String'>
    readonly Is_Discontinued: FieldRef<"Inventory", 'Boolean'>
    readonly Stock_Quantity: FieldRef<"Inventory", 'Int'>
    readonly Reorder_Threshold: FieldRef<"Inventory", 'Int'>
    readonly Total_Value: FieldRef<"Inventory", 'Float'>
    readonly Unit_Of_Measurement: FieldRef<"Inventory", 'String'>
    readonly Unit_Price: FieldRef<"Inventory", 'Float'>
    readonly Stock_Status: FieldRef<"Inventory", 'String'>
    readonly Storage_Location: FieldRef<"Inventory", 'String'>
    readonly Expiry_Date: FieldRef<"Inventory", 'DateTime'>
    readonly Initial_Stock_Quantity: FieldRef<"Inventory", 'Int'>
    readonly Supplier_Id: FieldRef<"Inventory", 'Int'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
  }

  /**
   * Inventory.Supplier
   */
  export type Inventory$SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Inventory.Inventory_Purchases
   */
  export type Inventory$Inventory_PurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    where?: InventoryPurchaseWhereInput
    orderBy?: InventoryPurchaseOrderByWithRelationInput | InventoryPurchaseOrderByWithRelationInput[]
    cursor?: InventoryPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryPurchaseScalarFieldEnum | InventoryPurchaseScalarFieldEnum[]
  }

  /**
   * Inventory.Withdrawal_Logs
   */
  export type Inventory$Withdrawal_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    where?: WithdrawalLogWhereInput
    orderBy?: WithdrawalLogOrderByWithRelationInput | WithdrawalLogOrderByWithRelationInput[]
    cursor?: WithdrawalLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawalLogScalarFieldEnum | WithdrawalLogScalarFieldEnum[]
  }

  /**
   * Inventory.Stock_Batches
   */
  export type Inventory$Stock_BatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    where?: StockBatchWhereInput
    orderBy?: StockBatchOrderByWithRelationInput | StockBatchOrderByWithRelationInput[]
    cursor?: StockBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockBatchScalarFieldEnum | StockBatchScalarFieldEnum[]
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model WithdrawalLog
   */

  export type AggregateWithdrawalLog = {
    _count: WithdrawalLogCountAggregateOutputType | null
    _avg: WithdrawalLogAvgAggregateOutputType | null
    _sum: WithdrawalLogSumAggregateOutputType | null
    _min: WithdrawalLogMinAggregateOutputType | null
    _max: WithdrawalLogMaxAggregateOutputType | null
  }

  export type WithdrawalLogAvgAggregateOutputType = {
    WithdrawalLog_Id: number | null
    Inventory_Id: number | null
    Employee_Id: number | null
    Quantity_Withdrawn: number | null
  }

  export type WithdrawalLogSumAggregateOutputType = {
    WithdrawalLog_Id: number | null
    Inventory_Id: number | null
    Employee_Id: number | null
    Quantity_Withdrawn: number | null
  }

  export type WithdrawalLogMinAggregateOutputType = {
    WithdrawalLog_Id: number | null
    Inventory_Id: number | null
    Employee_Id: number | null
    Withdrawal_Reason: string | null
    Quantity_Withdrawn: number | null
    Date_Withdrawn: Date | null
    updatedAt: Date | null
  }

  export type WithdrawalLogMaxAggregateOutputType = {
    WithdrawalLog_Id: number | null
    Inventory_Id: number | null
    Employee_Id: number | null
    Withdrawal_Reason: string | null
    Quantity_Withdrawn: number | null
    Date_Withdrawn: Date | null
    updatedAt: Date | null
  }

  export type WithdrawalLogCountAggregateOutputType = {
    WithdrawalLog_Id: number
    Inventory_Id: number
    Employee_Id: number
    Withdrawal_Reason: number
    Quantity_Withdrawn: number
    Date_Withdrawn: number
    updatedAt: number
    _all: number
  }


  export type WithdrawalLogAvgAggregateInputType = {
    WithdrawalLog_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Quantity_Withdrawn?: true
  }

  export type WithdrawalLogSumAggregateInputType = {
    WithdrawalLog_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Quantity_Withdrawn?: true
  }

  export type WithdrawalLogMinAggregateInputType = {
    WithdrawalLog_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Withdrawal_Reason?: true
    Quantity_Withdrawn?: true
    Date_Withdrawn?: true
    updatedAt?: true
  }

  export type WithdrawalLogMaxAggregateInputType = {
    WithdrawalLog_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Withdrawal_Reason?: true
    Quantity_Withdrawn?: true
    Date_Withdrawn?: true
    updatedAt?: true
  }

  export type WithdrawalLogCountAggregateInputType = {
    WithdrawalLog_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Withdrawal_Reason?: true
    Quantity_Withdrawn?: true
    Date_Withdrawn?: true
    updatedAt?: true
    _all?: true
  }

  export type WithdrawalLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WithdrawalLog to aggregate.
     */
    where?: WithdrawalLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WithdrawalLogs to fetch.
     */
    orderBy?: WithdrawalLogOrderByWithRelationInput | WithdrawalLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WithdrawalLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WithdrawalLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WithdrawalLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WithdrawalLogs
    **/
    _count?: true | WithdrawalLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalLogMaxAggregateInputType
  }

  export type GetWithdrawalLogAggregateType<T extends WithdrawalLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawalLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawalLog[P]>
      : GetScalarType<T[P], AggregateWithdrawalLog[P]>
  }




  export type WithdrawalLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawalLogWhereInput
    orderBy?: WithdrawalLogOrderByWithAggregationInput | WithdrawalLogOrderByWithAggregationInput[]
    by: WithdrawalLogScalarFieldEnum[] | WithdrawalLogScalarFieldEnum
    having?: WithdrawalLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalLogCountAggregateInputType | true
    _avg?: WithdrawalLogAvgAggregateInputType
    _sum?: WithdrawalLogSumAggregateInputType
    _min?: WithdrawalLogMinAggregateInputType
    _max?: WithdrawalLogMaxAggregateInputType
  }

  export type WithdrawalLogGroupByOutputType = {
    WithdrawalLog_Id: number
    Inventory_Id: number
    Employee_Id: number | null
    Withdrawal_Reason: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn: Date
    updatedAt: Date | null
    _count: WithdrawalLogCountAggregateOutputType | null
    _avg: WithdrawalLogAvgAggregateOutputType | null
    _sum: WithdrawalLogSumAggregateOutputType | null
    _min: WithdrawalLogMinAggregateOutputType | null
    _max: WithdrawalLogMaxAggregateOutputType | null
  }

  type GetWithdrawalLogGroupByPayload<T extends WithdrawalLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawalLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalLogGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalLogGroupByOutputType[P]>
        }
      >
    >


  export type WithdrawalLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    WithdrawalLog_Id?: boolean
    Inventory_Id?: boolean
    Employee_Id?: boolean
    Withdrawal_Reason?: boolean
    Quantity_Withdrawn?: boolean
    Date_Withdrawn?: boolean
    updatedAt?: boolean
    Inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Employee?: boolean | WithdrawalLog$EmployeeArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawalLog"]>



  export type WithdrawalLogSelectScalar = {
    WithdrawalLog_Id?: boolean
    Inventory_Id?: boolean
    Employee_Id?: boolean
    Withdrawal_Reason?: boolean
    Quantity_Withdrawn?: boolean
    Date_Withdrawn?: boolean
    updatedAt?: boolean
  }

  export type WithdrawalLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"WithdrawalLog_Id" | "Inventory_Id" | "Employee_Id" | "Withdrawal_Reason" | "Quantity_Withdrawn" | "Date_Withdrawn" | "updatedAt", ExtArgs["result"]["withdrawalLog"]>
  export type WithdrawalLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Employee?: boolean | WithdrawalLog$EmployeeArgs<ExtArgs>
  }

  export type $WithdrawalLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WithdrawalLog"
    objects: {
      Inventory: Prisma.$InventoryPayload<ExtArgs>
      Employee: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      WithdrawalLog_Id: number
      Inventory_Id: number
      Employee_Id: number | null
      Withdrawal_Reason: string | null
      Quantity_Withdrawn: number
      Date_Withdrawn: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["withdrawalLog"]>
    composites: {}
  }

  type WithdrawalLogGetPayload<S extends boolean | null | undefined | WithdrawalLogDefaultArgs> = $Result.GetResult<Prisma.$WithdrawalLogPayload, S>

  type WithdrawalLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WithdrawalLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WithdrawalLogCountAggregateInputType | true
    }

  export interface WithdrawalLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WithdrawalLog'], meta: { name: 'WithdrawalLog' } }
    /**
     * Find zero or one WithdrawalLog that matches the filter.
     * @param {WithdrawalLogFindUniqueArgs} args - Arguments to find a WithdrawalLog
     * @example
     * // Get one WithdrawalLog
     * const withdrawalLog = await prisma.withdrawalLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WithdrawalLogFindUniqueArgs>(args: SelectSubset<T, WithdrawalLogFindUniqueArgs<ExtArgs>>): Prisma__WithdrawalLogClient<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WithdrawalLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WithdrawalLogFindUniqueOrThrowArgs} args - Arguments to find a WithdrawalLog
     * @example
     * // Get one WithdrawalLog
     * const withdrawalLog = await prisma.withdrawalLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WithdrawalLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WithdrawalLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WithdrawalLogClient<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WithdrawalLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalLogFindFirstArgs} args - Arguments to find a WithdrawalLog
     * @example
     * // Get one WithdrawalLog
     * const withdrawalLog = await prisma.withdrawalLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WithdrawalLogFindFirstArgs>(args?: SelectSubset<T, WithdrawalLogFindFirstArgs<ExtArgs>>): Prisma__WithdrawalLogClient<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WithdrawalLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalLogFindFirstOrThrowArgs} args - Arguments to find a WithdrawalLog
     * @example
     * // Get one WithdrawalLog
     * const withdrawalLog = await prisma.withdrawalLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WithdrawalLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WithdrawalLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WithdrawalLogClient<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WithdrawalLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WithdrawalLogs
     * const withdrawalLogs = await prisma.withdrawalLog.findMany()
     * 
     * // Get first 10 WithdrawalLogs
     * const withdrawalLogs = await prisma.withdrawalLog.findMany({ take: 10 })
     * 
     * // Only select the `WithdrawalLog_Id`
     * const withdrawalLogWithWithdrawalLog_IdOnly = await prisma.withdrawalLog.findMany({ select: { WithdrawalLog_Id: true } })
     * 
     */
    findMany<T extends WithdrawalLogFindManyArgs>(args?: SelectSubset<T, WithdrawalLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WithdrawalLog.
     * @param {WithdrawalLogCreateArgs} args - Arguments to create a WithdrawalLog.
     * @example
     * // Create one WithdrawalLog
     * const WithdrawalLog = await prisma.withdrawalLog.create({
     *   data: {
     *     // ... data to create a WithdrawalLog
     *   }
     * })
     * 
     */
    create<T extends WithdrawalLogCreateArgs>(args: SelectSubset<T, WithdrawalLogCreateArgs<ExtArgs>>): Prisma__WithdrawalLogClient<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WithdrawalLogs.
     * @param {WithdrawalLogCreateManyArgs} args - Arguments to create many WithdrawalLogs.
     * @example
     * // Create many WithdrawalLogs
     * const withdrawalLog = await prisma.withdrawalLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WithdrawalLogCreateManyArgs>(args?: SelectSubset<T, WithdrawalLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WithdrawalLog.
     * @param {WithdrawalLogDeleteArgs} args - Arguments to delete one WithdrawalLog.
     * @example
     * // Delete one WithdrawalLog
     * const WithdrawalLog = await prisma.withdrawalLog.delete({
     *   where: {
     *     // ... filter to delete one WithdrawalLog
     *   }
     * })
     * 
     */
    delete<T extends WithdrawalLogDeleteArgs>(args: SelectSubset<T, WithdrawalLogDeleteArgs<ExtArgs>>): Prisma__WithdrawalLogClient<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WithdrawalLog.
     * @param {WithdrawalLogUpdateArgs} args - Arguments to update one WithdrawalLog.
     * @example
     * // Update one WithdrawalLog
     * const withdrawalLog = await prisma.withdrawalLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WithdrawalLogUpdateArgs>(args: SelectSubset<T, WithdrawalLogUpdateArgs<ExtArgs>>): Prisma__WithdrawalLogClient<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WithdrawalLogs.
     * @param {WithdrawalLogDeleteManyArgs} args - Arguments to filter WithdrawalLogs to delete.
     * @example
     * // Delete a few WithdrawalLogs
     * const { count } = await prisma.withdrawalLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WithdrawalLogDeleteManyArgs>(args?: SelectSubset<T, WithdrawalLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WithdrawalLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WithdrawalLogs
     * const withdrawalLog = await prisma.withdrawalLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WithdrawalLogUpdateManyArgs>(args: SelectSubset<T, WithdrawalLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WithdrawalLog.
     * @param {WithdrawalLogUpsertArgs} args - Arguments to update or create a WithdrawalLog.
     * @example
     * // Update or create a WithdrawalLog
     * const withdrawalLog = await prisma.withdrawalLog.upsert({
     *   create: {
     *     // ... data to create a WithdrawalLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WithdrawalLog we want to update
     *   }
     * })
     */
    upsert<T extends WithdrawalLogUpsertArgs>(args: SelectSubset<T, WithdrawalLogUpsertArgs<ExtArgs>>): Prisma__WithdrawalLogClient<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WithdrawalLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalLogCountArgs} args - Arguments to filter WithdrawalLogs to count.
     * @example
     * // Count the number of WithdrawalLogs
     * const count = await prisma.withdrawalLog.count({
     *   where: {
     *     // ... the filter for the WithdrawalLogs we want to count
     *   }
     * })
    **/
    count<T extends WithdrawalLogCountArgs>(
      args?: Subset<T, WithdrawalLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WithdrawalLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalLogAggregateArgs>(args: Subset<T, WithdrawalLogAggregateArgs>): Prisma.PrismaPromise<GetWithdrawalLogAggregateType<T>>

    /**
     * Group by WithdrawalLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WithdrawalLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WithdrawalLogGroupByArgs['orderBy'] }
        : { orderBy?: WithdrawalLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WithdrawalLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WithdrawalLog model
   */
  readonly fields: WithdrawalLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WithdrawalLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WithdrawalLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Employee<T extends WithdrawalLog$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, WithdrawalLog$EmployeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WithdrawalLog model
   */ 
  interface WithdrawalLogFieldRefs {
    readonly WithdrawalLog_Id: FieldRef<"WithdrawalLog", 'Int'>
    readonly Inventory_Id: FieldRef<"WithdrawalLog", 'Int'>
    readonly Employee_Id: FieldRef<"WithdrawalLog", 'Int'>
    readonly Withdrawal_Reason: FieldRef<"WithdrawalLog", 'String'>
    readonly Quantity_Withdrawn: FieldRef<"WithdrawalLog", 'Int'>
    readonly Date_Withdrawn: FieldRef<"WithdrawalLog", 'DateTime'>
    readonly updatedAt: FieldRef<"WithdrawalLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WithdrawalLog findUnique
   */
  export type WithdrawalLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    /**
     * Filter, which WithdrawalLog to fetch.
     */
    where: WithdrawalLogWhereUniqueInput
  }

  /**
   * WithdrawalLog findUniqueOrThrow
   */
  export type WithdrawalLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    /**
     * Filter, which WithdrawalLog to fetch.
     */
    where: WithdrawalLogWhereUniqueInput
  }

  /**
   * WithdrawalLog findFirst
   */
  export type WithdrawalLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    /**
     * Filter, which WithdrawalLog to fetch.
     */
    where?: WithdrawalLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WithdrawalLogs to fetch.
     */
    orderBy?: WithdrawalLogOrderByWithRelationInput | WithdrawalLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WithdrawalLogs.
     */
    cursor?: WithdrawalLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WithdrawalLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WithdrawalLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WithdrawalLogs.
     */
    distinct?: WithdrawalLogScalarFieldEnum | WithdrawalLogScalarFieldEnum[]
  }

  /**
   * WithdrawalLog findFirstOrThrow
   */
  export type WithdrawalLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    /**
     * Filter, which WithdrawalLog to fetch.
     */
    where?: WithdrawalLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WithdrawalLogs to fetch.
     */
    orderBy?: WithdrawalLogOrderByWithRelationInput | WithdrawalLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WithdrawalLogs.
     */
    cursor?: WithdrawalLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WithdrawalLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WithdrawalLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WithdrawalLogs.
     */
    distinct?: WithdrawalLogScalarFieldEnum | WithdrawalLogScalarFieldEnum[]
  }

  /**
   * WithdrawalLog findMany
   */
  export type WithdrawalLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    /**
     * Filter, which WithdrawalLogs to fetch.
     */
    where?: WithdrawalLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WithdrawalLogs to fetch.
     */
    orderBy?: WithdrawalLogOrderByWithRelationInput | WithdrawalLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WithdrawalLogs.
     */
    cursor?: WithdrawalLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WithdrawalLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WithdrawalLogs.
     */
    skip?: number
    distinct?: WithdrawalLogScalarFieldEnum | WithdrawalLogScalarFieldEnum[]
  }

  /**
   * WithdrawalLog create
   */
  export type WithdrawalLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    /**
     * The data needed to create a WithdrawalLog.
     */
    data: XOR<WithdrawalLogCreateInput, WithdrawalLogUncheckedCreateInput>
  }

  /**
   * WithdrawalLog createMany
   */
  export type WithdrawalLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WithdrawalLogs.
     */
    data: WithdrawalLogCreateManyInput | WithdrawalLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WithdrawalLog update
   */
  export type WithdrawalLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    /**
     * The data needed to update a WithdrawalLog.
     */
    data: XOR<WithdrawalLogUpdateInput, WithdrawalLogUncheckedUpdateInput>
    /**
     * Choose, which WithdrawalLog to update.
     */
    where: WithdrawalLogWhereUniqueInput
  }

  /**
   * WithdrawalLog updateMany
   */
  export type WithdrawalLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WithdrawalLogs.
     */
    data: XOR<WithdrawalLogUpdateManyMutationInput, WithdrawalLogUncheckedUpdateManyInput>
    /**
     * Filter which WithdrawalLogs to update
     */
    where?: WithdrawalLogWhereInput
  }

  /**
   * WithdrawalLog upsert
   */
  export type WithdrawalLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    /**
     * The filter to search for the WithdrawalLog to update in case it exists.
     */
    where: WithdrawalLogWhereUniqueInput
    /**
     * In case the WithdrawalLog found by the `where` argument doesn't exist, create a new WithdrawalLog with this data.
     */
    create: XOR<WithdrawalLogCreateInput, WithdrawalLogUncheckedCreateInput>
    /**
     * In case the WithdrawalLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WithdrawalLogUpdateInput, WithdrawalLogUncheckedUpdateInput>
  }

  /**
   * WithdrawalLog delete
   */
  export type WithdrawalLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    /**
     * Filter which WithdrawalLog to delete.
     */
    where: WithdrawalLogWhereUniqueInput
  }

  /**
   * WithdrawalLog deleteMany
   */
  export type WithdrawalLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WithdrawalLogs to delete
     */
    where?: WithdrawalLogWhereInput
  }

  /**
   * WithdrawalLog.Employee
   */
  export type WithdrawalLog$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * WithdrawalLog without action
   */
  export type WithdrawalLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
  }


  /**
   * Model InventoryPurchase
   */

  export type AggregateInventoryPurchase = {
    _count: InventoryPurchaseCountAggregateOutputType | null
    _avg: InventoryPurchaseAvgAggregateOutputType | null
    _sum: InventoryPurchaseSumAggregateOutputType | null
    _min: InventoryPurchaseMinAggregateOutputType | null
    _max: InventoryPurchaseMaxAggregateOutputType | null
  }

  export type InventoryPurchaseAvgAggregateOutputType = {
    Purchase_Id: number | null
    Inventory_Id: number | null
    Employee_Id: number | null
    Supplier_Id: number | null
    Quantity_Purchased: number | null
    Total_Cost: number | null
    Unit_Price: number | null
  }

  export type InventoryPurchaseSumAggregateOutputType = {
    Purchase_Id: number | null
    Inventory_Id: number | null
    Employee_Id: number | null
    Supplier_Id: number | null
    Quantity_Purchased: number | null
    Total_Cost: number | null
    Unit_Price: number | null
  }

  export type InventoryPurchaseMinAggregateOutputType = {
    Purchase_Id: number | null
    Inventory_Id: number | null
    Employee_Id: number | null
    Supplier_Id: number | null
    Purchase_Date: Date | null
    Quantity_Purchased: number | null
    Total_Cost: number | null
    Unit_Price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryPurchaseMaxAggregateOutputType = {
    Purchase_Id: number | null
    Inventory_Id: number | null
    Employee_Id: number | null
    Supplier_Id: number | null
    Purchase_Date: Date | null
    Quantity_Purchased: number | null
    Total_Cost: number | null
    Unit_Price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryPurchaseCountAggregateOutputType = {
    Purchase_Id: number
    Inventory_Id: number
    Employee_Id: number
    Supplier_Id: number
    Purchase_Date: number
    Quantity_Purchased: number
    Total_Cost: number
    Unit_Price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryPurchaseAvgAggregateInputType = {
    Purchase_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Supplier_Id?: true
    Quantity_Purchased?: true
    Total_Cost?: true
    Unit_Price?: true
  }

  export type InventoryPurchaseSumAggregateInputType = {
    Purchase_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Supplier_Id?: true
    Quantity_Purchased?: true
    Total_Cost?: true
    Unit_Price?: true
  }

  export type InventoryPurchaseMinAggregateInputType = {
    Purchase_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Supplier_Id?: true
    Purchase_Date?: true
    Quantity_Purchased?: true
    Total_Cost?: true
    Unit_Price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryPurchaseMaxAggregateInputType = {
    Purchase_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Supplier_Id?: true
    Purchase_Date?: true
    Quantity_Purchased?: true
    Total_Cost?: true
    Unit_Price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryPurchaseCountAggregateInputType = {
    Purchase_Id?: true
    Inventory_Id?: true
    Employee_Id?: true
    Supplier_Id?: true
    Purchase_Date?: true
    Quantity_Purchased?: true
    Total_Cost?: true
    Unit_Price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryPurchase to aggregate.
     */
    where?: InventoryPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryPurchases to fetch.
     */
    orderBy?: InventoryPurchaseOrderByWithRelationInput | InventoryPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryPurchases
    **/
    _count?: true | InventoryPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryPurchaseMaxAggregateInputType
  }

  export type GetInventoryPurchaseAggregateType<T extends InventoryPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryPurchase[P]>
      : GetScalarType<T[P], AggregateInventoryPurchase[P]>
  }




  export type InventoryPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryPurchaseWhereInput
    orderBy?: InventoryPurchaseOrderByWithAggregationInput | InventoryPurchaseOrderByWithAggregationInput[]
    by: InventoryPurchaseScalarFieldEnum[] | InventoryPurchaseScalarFieldEnum
    having?: InventoryPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryPurchaseCountAggregateInputType | true
    _avg?: InventoryPurchaseAvgAggregateInputType
    _sum?: InventoryPurchaseSumAggregateInputType
    _min?: InventoryPurchaseMinAggregateInputType
    _max?: InventoryPurchaseMaxAggregateInputType
  }

  export type InventoryPurchaseGroupByOutputType = {
    Purchase_Id: number
    Inventory_Id: number
    Employee_Id: number | null
    Supplier_Id: number | null
    Purchase_Date: Date
    Quantity_Purchased: number
    Total_Cost: number | null
    Unit_Price: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: InventoryPurchaseCountAggregateOutputType | null
    _avg: InventoryPurchaseAvgAggregateOutputType | null
    _sum: InventoryPurchaseSumAggregateOutputType | null
    _min: InventoryPurchaseMinAggregateOutputType | null
    _max: InventoryPurchaseMaxAggregateOutputType | null
  }

  type GetInventoryPurchaseGroupByPayload<T extends InventoryPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type InventoryPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Purchase_Id?: boolean
    Inventory_Id?: boolean
    Employee_Id?: boolean
    Supplier_Id?: boolean
    Purchase_Date?: boolean
    Quantity_Purchased?: boolean
    Total_Cost?: boolean
    Unit_Price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Supplier?: boolean | InventoryPurchase$SupplierArgs<ExtArgs>
    Employee?: boolean | InventoryPurchase$EmployeeArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryPurchase"]>



  export type InventoryPurchaseSelectScalar = {
    Purchase_Id?: boolean
    Inventory_Id?: boolean
    Employee_Id?: boolean
    Supplier_Id?: boolean
    Purchase_Date?: boolean
    Quantity_Purchased?: boolean
    Total_Cost?: boolean
    Unit_Price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Purchase_Id" | "Inventory_Id" | "Employee_Id" | "Supplier_Id" | "Purchase_Date" | "Quantity_Purchased" | "Total_Cost" | "Unit_Price" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryPurchase"]>
  export type InventoryPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Supplier?: boolean | InventoryPurchase$SupplierArgs<ExtArgs>
    Employee?: boolean | InventoryPurchase$EmployeeArgs<ExtArgs>
  }

  export type $InventoryPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryPurchase"
    objects: {
      Inventory: Prisma.$InventoryPayload<ExtArgs>
      Supplier: Prisma.$SupplierPayload<ExtArgs> | null
      Employee: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      Purchase_Id: number
      Inventory_Id: number
      Employee_Id: number | null
      Supplier_Id: number | null
      Purchase_Date: Date
      Quantity_Purchased: number
      Total_Cost: number | null
      Unit_Price: number | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["inventoryPurchase"]>
    composites: {}
  }

  type InventoryPurchaseGetPayload<S extends boolean | null | undefined | InventoryPurchaseDefaultArgs> = $Result.GetResult<Prisma.$InventoryPurchasePayload, S>

  type InventoryPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryPurchaseCountAggregateInputType | true
    }

  export interface InventoryPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryPurchase'], meta: { name: 'InventoryPurchase' } }
    /**
     * Find zero or one InventoryPurchase that matches the filter.
     * @param {InventoryPurchaseFindUniqueArgs} args - Arguments to find a InventoryPurchase
     * @example
     * // Get one InventoryPurchase
     * const inventoryPurchase = await prisma.inventoryPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryPurchaseFindUniqueArgs>(args: SelectSubset<T, InventoryPurchaseFindUniqueArgs<ExtArgs>>): Prisma__InventoryPurchaseClient<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one InventoryPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryPurchaseFindUniqueOrThrowArgs} args - Arguments to find a InventoryPurchase
     * @example
     * // Get one InventoryPurchase
     * const inventoryPurchase = await prisma.inventoryPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryPurchaseClient<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first InventoryPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryPurchaseFindFirstArgs} args - Arguments to find a InventoryPurchase
     * @example
     * // Get one InventoryPurchase
     * const inventoryPurchase = await prisma.inventoryPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryPurchaseFindFirstArgs>(args?: SelectSubset<T, InventoryPurchaseFindFirstArgs<ExtArgs>>): Prisma__InventoryPurchaseClient<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first InventoryPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryPurchaseFindFirstOrThrowArgs} args - Arguments to find a InventoryPurchase
     * @example
     * // Get one InventoryPurchase
     * const inventoryPurchase = await prisma.inventoryPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryPurchaseClient<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more InventoryPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryPurchases
     * const inventoryPurchases = await prisma.inventoryPurchase.findMany()
     * 
     * // Get first 10 InventoryPurchases
     * const inventoryPurchases = await prisma.inventoryPurchase.findMany({ take: 10 })
     * 
     * // Only select the `Purchase_Id`
     * const inventoryPurchaseWithPurchase_IdOnly = await prisma.inventoryPurchase.findMany({ select: { Purchase_Id: true } })
     * 
     */
    findMany<T extends InventoryPurchaseFindManyArgs>(args?: SelectSubset<T, InventoryPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a InventoryPurchase.
     * @param {InventoryPurchaseCreateArgs} args - Arguments to create a InventoryPurchase.
     * @example
     * // Create one InventoryPurchase
     * const InventoryPurchase = await prisma.inventoryPurchase.create({
     *   data: {
     *     // ... data to create a InventoryPurchase
     *   }
     * })
     * 
     */
    create<T extends InventoryPurchaseCreateArgs>(args: SelectSubset<T, InventoryPurchaseCreateArgs<ExtArgs>>): Prisma__InventoryPurchaseClient<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many InventoryPurchases.
     * @param {InventoryPurchaseCreateManyArgs} args - Arguments to create many InventoryPurchases.
     * @example
     * // Create many InventoryPurchases
     * const inventoryPurchase = await prisma.inventoryPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryPurchaseCreateManyArgs>(args?: SelectSubset<T, InventoryPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryPurchase.
     * @param {InventoryPurchaseDeleteArgs} args - Arguments to delete one InventoryPurchase.
     * @example
     * // Delete one InventoryPurchase
     * const InventoryPurchase = await prisma.inventoryPurchase.delete({
     *   where: {
     *     // ... filter to delete one InventoryPurchase
     *   }
     * })
     * 
     */
    delete<T extends InventoryPurchaseDeleteArgs>(args: SelectSubset<T, InventoryPurchaseDeleteArgs<ExtArgs>>): Prisma__InventoryPurchaseClient<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one InventoryPurchase.
     * @param {InventoryPurchaseUpdateArgs} args - Arguments to update one InventoryPurchase.
     * @example
     * // Update one InventoryPurchase
     * const inventoryPurchase = await prisma.inventoryPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryPurchaseUpdateArgs>(args: SelectSubset<T, InventoryPurchaseUpdateArgs<ExtArgs>>): Prisma__InventoryPurchaseClient<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more InventoryPurchases.
     * @param {InventoryPurchaseDeleteManyArgs} args - Arguments to filter InventoryPurchases to delete.
     * @example
     * // Delete a few InventoryPurchases
     * const { count } = await prisma.inventoryPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryPurchaseDeleteManyArgs>(args?: SelectSubset<T, InventoryPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryPurchases
     * const inventoryPurchase = await prisma.inventoryPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryPurchaseUpdateManyArgs>(args: SelectSubset<T, InventoryPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryPurchase.
     * @param {InventoryPurchaseUpsertArgs} args - Arguments to update or create a InventoryPurchase.
     * @example
     * // Update or create a InventoryPurchase
     * const inventoryPurchase = await prisma.inventoryPurchase.upsert({
     *   create: {
     *     // ... data to create a InventoryPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryPurchase we want to update
     *   }
     * })
     */
    upsert<T extends InventoryPurchaseUpsertArgs>(args: SelectSubset<T, InventoryPurchaseUpsertArgs<ExtArgs>>): Prisma__InventoryPurchaseClient<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of InventoryPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryPurchaseCountArgs} args - Arguments to filter InventoryPurchases to count.
     * @example
     * // Count the number of InventoryPurchases
     * const count = await prisma.inventoryPurchase.count({
     *   where: {
     *     // ... the filter for the InventoryPurchases we want to count
     *   }
     * })
    **/
    count<T extends InventoryPurchaseCountArgs>(
      args?: Subset<T, InventoryPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryPurchaseAggregateArgs>(args: Subset<T, InventoryPurchaseAggregateArgs>): Prisma.PrismaPromise<GetInventoryPurchaseAggregateType<T>>

    /**
     * Group by InventoryPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: InventoryPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryPurchase model
   */
  readonly fields: InventoryPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Supplier<T extends InventoryPurchase$SupplierArgs<ExtArgs> = {}>(args?: Subset<T, InventoryPurchase$SupplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Employee<T extends InventoryPurchase$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, InventoryPurchase$EmployeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryPurchase model
   */ 
  interface InventoryPurchaseFieldRefs {
    readonly Purchase_Id: FieldRef<"InventoryPurchase", 'Int'>
    readonly Inventory_Id: FieldRef<"InventoryPurchase", 'Int'>
    readonly Employee_Id: FieldRef<"InventoryPurchase", 'Int'>
    readonly Supplier_Id: FieldRef<"InventoryPurchase", 'Int'>
    readonly Purchase_Date: FieldRef<"InventoryPurchase", 'DateTime'>
    readonly Quantity_Purchased: FieldRef<"InventoryPurchase", 'Int'>
    readonly Total_Cost: FieldRef<"InventoryPurchase", 'Float'>
    readonly Unit_Price: FieldRef<"InventoryPurchase", 'Float'>
    readonly createdAt: FieldRef<"InventoryPurchase", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryPurchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryPurchase findUnique
   */
  export type InventoryPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which InventoryPurchase to fetch.
     */
    where: InventoryPurchaseWhereUniqueInput
  }

  /**
   * InventoryPurchase findUniqueOrThrow
   */
  export type InventoryPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which InventoryPurchase to fetch.
     */
    where: InventoryPurchaseWhereUniqueInput
  }

  /**
   * InventoryPurchase findFirst
   */
  export type InventoryPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which InventoryPurchase to fetch.
     */
    where?: InventoryPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryPurchases to fetch.
     */
    orderBy?: InventoryPurchaseOrderByWithRelationInput | InventoryPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryPurchases.
     */
    cursor?: InventoryPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryPurchases.
     */
    distinct?: InventoryPurchaseScalarFieldEnum | InventoryPurchaseScalarFieldEnum[]
  }

  /**
   * InventoryPurchase findFirstOrThrow
   */
  export type InventoryPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which InventoryPurchase to fetch.
     */
    where?: InventoryPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryPurchases to fetch.
     */
    orderBy?: InventoryPurchaseOrderByWithRelationInput | InventoryPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryPurchases.
     */
    cursor?: InventoryPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryPurchases.
     */
    distinct?: InventoryPurchaseScalarFieldEnum | InventoryPurchaseScalarFieldEnum[]
  }

  /**
   * InventoryPurchase findMany
   */
  export type InventoryPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which InventoryPurchases to fetch.
     */
    where?: InventoryPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryPurchases to fetch.
     */
    orderBy?: InventoryPurchaseOrderByWithRelationInput | InventoryPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryPurchases.
     */
    cursor?: InventoryPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryPurchases.
     */
    skip?: number
    distinct?: InventoryPurchaseScalarFieldEnum | InventoryPurchaseScalarFieldEnum[]
  }

  /**
   * InventoryPurchase create
   */
  export type InventoryPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryPurchase.
     */
    data: XOR<InventoryPurchaseCreateInput, InventoryPurchaseUncheckedCreateInput>
  }

  /**
   * InventoryPurchase createMany
   */
  export type InventoryPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryPurchases.
     */
    data: InventoryPurchaseCreateManyInput | InventoryPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryPurchase update
   */
  export type InventoryPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryPurchase.
     */
    data: XOR<InventoryPurchaseUpdateInput, InventoryPurchaseUncheckedUpdateInput>
    /**
     * Choose, which InventoryPurchase to update.
     */
    where: InventoryPurchaseWhereUniqueInput
  }

  /**
   * InventoryPurchase updateMany
   */
  export type InventoryPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryPurchases.
     */
    data: XOR<InventoryPurchaseUpdateManyMutationInput, InventoryPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which InventoryPurchases to update
     */
    where?: InventoryPurchaseWhereInput
  }

  /**
   * InventoryPurchase upsert
   */
  export type InventoryPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryPurchase to update in case it exists.
     */
    where: InventoryPurchaseWhereUniqueInput
    /**
     * In case the InventoryPurchase found by the `where` argument doesn't exist, create a new InventoryPurchase with this data.
     */
    create: XOR<InventoryPurchaseCreateInput, InventoryPurchaseUncheckedCreateInput>
    /**
     * In case the InventoryPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryPurchaseUpdateInput, InventoryPurchaseUncheckedUpdateInput>
  }

  /**
   * InventoryPurchase delete
   */
  export type InventoryPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    /**
     * Filter which InventoryPurchase to delete.
     */
    where: InventoryPurchaseWhereUniqueInput
  }

  /**
   * InventoryPurchase deleteMany
   */
  export type InventoryPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryPurchases to delete
     */
    where?: InventoryPurchaseWhereInput
  }

  /**
   * InventoryPurchase.Supplier
   */
  export type InventoryPurchase$SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * InventoryPurchase.Employee
   */
  export type InventoryPurchase$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * InventoryPurchase without action
   */
  export type InventoryPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model StockBatch
   */

  export type AggregateStockBatch = {
    _count: StockBatchCountAggregateOutputType | null
    _avg: StockBatchAvgAggregateOutputType | null
    _sum: StockBatchSumAggregateOutputType | null
    _min: StockBatchMinAggregateOutputType | null
    _max: StockBatchMaxAggregateOutputType | null
  }

  export type StockBatchAvgAggregateOutputType = {
    StockBatch_Id: number | null
    Inventory_Id: number | null
    Supplier_Id: number | null
    Quantity_Purchased: number | null
    Unit_Price: number | null
    Remaining_Quantity: number | null
  }

  export type StockBatchSumAggregateOutputType = {
    StockBatch_Id: number | null
    Inventory_Id: number | null
    Supplier_Id: number | null
    Quantity_Purchased: number | null
    Unit_Price: number | null
    Remaining_Quantity: number | null
  }

  export type StockBatchMinAggregateOutputType = {
    StockBatch_Id: number | null
    Batch_Number: string | null
    Inventory_Id: number | null
    Supplier_Id: number | null
    Purchase_Date: Date | null
    Quantity_Purchased: number | null
    Unit_Price: number | null
    Expiry_Date: Date | null
    Remaining_Quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockBatchMaxAggregateOutputType = {
    StockBatch_Id: number | null
    Batch_Number: string | null
    Inventory_Id: number | null
    Supplier_Id: number | null
    Purchase_Date: Date | null
    Quantity_Purchased: number | null
    Unit_Price: number | null
    Expiry_Date: Date | null
    Remaining_Quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockBatchCountAggregateOutputType = {
    StockBatch_Id: number
    Batch_Number: number
    Inventory_Id: number
    Supplier_Id: number
    Purchase_Date: number
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date: number
    Remaining_Quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockBatchAvgAggregateInputType = {
    StockBatch_Id?: true
    Inventory_Id?: true
    Supplier_Id?: true
    Quantity_Purchased?: true
    Unit_Price?: true
    Remaining_Quantity?: true
  }

  export type StockBatchSumAggregateInputType = {
    StockBatch_Id?: true
    Inventory_Id?: true
    Supplier_Id?: true
    Quantity_Purchased?: true
    Unit_Price?: true
    Remaining_Quantity?: true
  }

  export type StockBatchMinAggregateInputType = {
    StockBatch_Id?: true
    Batch_Number?: true
    Inventory_Id?: true
    Supplier_Id?: true
    Purchase_Date?: true
    Quantity_Purchased?: true
    Unit_Price?: true
    Expiry_Date?: true
    Remaining_Quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockBatchMaxAggregateInputType = {
    StockBatch_Id?: true
    Batch_Number?: true
    Inventory_Id?: true
    Supplier_Id?: true
    Purchase_Date?: true
    Quantity_Purchased?: true
    Unit_Price?: true
    Expiry_Date?: true
    Remaining_Quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockBatchCountAggregateInputType = {
    StockBatch_Id?: true
    Batch_Number?: true
    Inventory_Id?: true
    Supplier_Id?: true
    Purchase_Date?: true
    Quantity_Purchased?: true
    Unit_Price?: true
    Expiry_Date?: true
    Remaining_Quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockBatch to aggregate.
     */
    where?: StockBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockBatches to fetch.
     */
    orderBy?: StockBatchOrderByWithRelationInput | StockBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockBatches
    **/
    _count?: true | StockBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockBatchMaxAggregateInputType
  }

  export type GetStockBatchAggregateType<T extends StockBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateStockBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockBatch[P]>
      : GetScalarType<T[P], AggregateStockBatch[P]>
  }




  export type StockBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockBatchWhereInput
    orderBy?: StockBatchOrderByWithAggregationInput | StockBatchOrderByWithAggregationInput[]
    by: StockBatchScalarFieldEnum[] | StockBatchScalarFieldEnum
    having?: StockBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockBatchCountAggregateInputType | true
    _avg?: StockBatchAvgAggregateInputType
    _sum?: StockBatchSumAggregateInputType
    _min?: StockBatchMinAggregateInputType
    _max?: StockBatchMaxAggregateInputType
  }

  export type StockBatchGroupByOutputType = {
    StockBatch_Id: number
    Batch_Number: string
    Inventory_Id: number
    Supplier_Id: number | null
    Purchase_Date: Date
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date: Date | null
    Remaining_Quantity: number
    createdAt: Date
    updatedAt: Date | null
    _count: StockBatchCountAggregateOutputType | null
    _avg: StockBatchAvgAggregateOutputType | null
    _sum: StockBatchSumAggregateOutputType | null
    _min: StockBatchMinAggregateOutputType | null
    _max: StockBatchMaxAggregateOutputType | null
  }

  type GetStockBatchGroupByPayload<T extends StockBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockBatchGroupByOutputType[P]>
            : GetScalarType<T[P], StockBatchGroupByOutputType[P]>
        }
      >
    >


  export type StockBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    StockBatch_Id?: boolean
    Batch_Number?: boolean
    Inventory_Id?: boolean
    Supplier_Id?: boolean
    Purchase_Date?: boolean
    Quantity_Purchased?: boolean
    Unit_Price?: boolean
    Expiry_Date?: boolean
    Remaining_Quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Supplier?: boolean | StockBatch$SupplierArgs<ExtArgs>
  }, ExtArgs["result"]["stockBatch"]>



  export type StockBatchSelectScalar = {
    StockBatch_Id?: boolean
    Batch_Number?: boolean
    Inventory_Id?: boolean
    Supplier_Id?: boolean
    Purchase_Date?: boolean
    Quantity_Purchased?: boolean
    Unit_Price?: boolean
    Expiry_Date?: boolean
    Remaining_Quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockBatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"StockBatch_Id" | "Batch_Number" | "Inventory_Id" | "Supplier_Id" | "Purchase_Date" | "Quantity_Purchased" | "Unit_Price" | "Expiry_Date" | "Remaining_Quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["stockBatch"]>
  export type StockBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Supplier?: boolean | StockBatch$SupplierArgs<ExtArgs>
  }

  export type $StockBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockBatch"
    objects: {
      Inventory: Prisma.$InventoryPayload<ExtArgs>
      Supplier: Prisma.$SupplierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      StockBatch_Id: number
      Batch_Number: string
      Inventory_Id: number
      Supplier_Id: number | null
      Purchase_Date: Date
      Quantity_Purchased: number
      Unit_Price: number
      Expiry_Date: Date | null
      Remaining_Quantity: number
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["stockBatch"]>
    composites: {}
  }

  type StockBatchGetPayload<S extends boolean | null | undefined | StockBatchDefaultArgs> = $Result.GetResult<Prisma.$StockBatchPayload, S>

  type StockBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockBatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockBatchCountAggregateInputType | true
    }

  export interface StockBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockBatch'], meta: { name: 'StockBatch' } }
    /**
     * Find zero or one StockBatch that matches the filter.
     * @param {StockBatchFindUniqueArgs} args - Arguments to find a StockBatch
     * @example
     * // Get one StockBatch
     * const stockBatch = await prisma.stockBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockBatchFindUniqueArgs>(args: SelectSubset<T, StockBatchFindUniqueArgs<ExtArgs>>): Prisma__StockBatchClient<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one StockBatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockBatchFindUniqueOrThrowArgs} args - Arguments to find a StockBatch
     * @example
     * // Get one StockBatch
     * const stockBatch = await prisma.stockBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, StockBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockBatchClient<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first StockBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBatchFindFirstArgs} args - Arguments to find a StockBatch
     * @example
     * // Get one StockBatch
     * const stockBatch = await prisma.stockBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockBatchFindFirstArgs>(args?: SelectSubset<T, StockBatchFindFirstArgs<ExtArgs>>): Prisma__StockBatchClient<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first StockBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBatchFindFirstOrThrowArgs} args - Arguments to find a StockBatch
     * @example
     * // Get one StockBatch
     * const stockBatch = await prisma.stockBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, StockBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockBatchClient<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more StockBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockBatches
     * const stockBatches = await prisma.stockBatch.findMany()
     * 
     * // Get first 10 StockBatches
     * const stockBatches = await prisma.stockBatch.findMany({ take: 10 })
     * 
     * // Only select the `StockBatch_Id`
     * const stockBatchWithStockBatch_IdOnly = await prisma.stockBatch.findMany({ select: { StockBatch_Id: true } })
     * 
     */
    findMany<T extends StockBatchFindManyArgs>(args?: SelectSubset<T, StockBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a StockBatch.
     * @param {StockBatchCreateArgs} args - Arguments to create a StockBatch.
     * @example
     * // Create one StockBatch
     * const StockBatch = await prisma.stockBatch.create({
     *   data: {
     *     // ... data to create a StockBatch
     *   }
     * })
     * 
     */
    create<T extends StockBatchCreateArgs>(args: SelectSubset<T, StockBatchCreateArgs<ExtArgs>>): Prisma__StockBatchClient<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many StockBatches.
     * @param {StockBatchCreateManyArgs} args - Arguments to create many StockBatches.
     * @example
     * // Create many StockBatches
     * const stockBatch = await prisma.stockBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockBatchCreateManyArgs>(args?: SelectSubset<T, StockBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockBatch.
     * @param {StockBatchDeleteArgs} args - Arguments to delete one StockBatch.
     * @example
     * // Delete one StockBatch
     * const StockBatch = await prisma.stockBatch.delete({
     *   where: {
     *     // ... filter to delete one StockBatch
     *   }
     * })
     * 
     */
    delete<T extends StockBatchDeleteArgs>(args: SelectSubset<T, StockBatchDeleteArgs<ExtArgs>>): Prisma__StockBatchClient<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one StockBatch.
     * @param {StockBatchUpdateArgs} args - Arguments to update one StockBatch.
     * @example
     * // Update one StockBatch
     * const stockBatch = await prisma.stockBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockBatchUpdateArgs>(args: SelectSubset<T, StockBatchUpdateArgs<ExtArgs>>): Prisma__StockBatchClient<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more StockBatches.
     * @param {StockBatchDeleteManyArgs} args - Arguments to filter StockBatches to delete.
     * @example
     * // Delete a few StockBatches
     * const { count } = await prisma.stockBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockBatchDeleteManyArgs>(args?: SelectSubset<T, StockBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockBatches
     * const stockBatch = await prisma.stockBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockBatchUpdateManyArgs>(args: SelectSubset<T, StockBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockBatch.
     * @param {StockBatchUpsertArgs} args - Arguments to update or create a StockBatch.
     * @example
     * // Update or create a StockBatch
     * const stockBatch = await prisma.stockBatch.upsert({
     *   create: {
     *     // ... data to create a StockBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockBatch we want to update
     *   }
     * })
     */
    upsert<T extends StockBatchUpsertArgs>(args: SelectSubset<T, StockBatchUpsertArgs<ExtArgs>>): Prisma__StockBatchClient<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of StockBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBatchCountArgs} args - Arguments to filter StockBatches to count.
     * @example
     * // Count the number of StockBatches
     * const count = await prisma.stockBatch.count({
     *   where: {
     *     // ... the filter for the StockBatches we want to count
     *   }
     * })
    **/
    count<T extends StockBatchCountArgs>(
      args?: Subset<T, StockBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockBatchAggregateArgs>(args: Subset<T, StockBatchAggregateArgs>): Prisma.PrismaPromise<GetStockBatchAggregateType<T>>

    /**
     * Group by StockBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockBatchGroupByArgs['orderBy'] }
        : { orderBy?: StockBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockBatch model
   */
  readonly fields: StockBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Supplier<T extends StockBatch$SupplierArgs<ExtArgs> = {}>(args?: Subset<T, StockBatch$SupplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockBatch model
   */ 
  interface StockBatchFieldRefs {
    readonly StockBatch_Id: FieldRef<"StockBatch", 'Int'>
    readonly Batch_Number: FieldRef<"StockBatch", 'String'>
    readonly Inventory_Id: FieldRef<"StockBatch", 'Int'>
    readonly Supplier_Id: FieldRef<"StockBatch", 'Int'>
    readonly Purchase_Date: FieldRef<"StockBatch", 'DateTime'>
    readonly Quantity_Purchased: FieldRef<"StockBatch", 'Int'>
    readonly Unit_Price: FieldRef<"StockBatch", 'Float'>
    readonly Expiry_Date: FieldRef<"StockBatch", 'DateTime'>
    readonly Remaining_Quantity: FieldRef<"StockBatch", 'Int'>
    readonly createdAt: FieldRef<"StockBatch", 'DateTime'>
    readonly updatedAt: FieldRef<"StockBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockBatch findUnique
   */
  export type StockBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    /**
     * Filter, which StockBatch to fetch.
     */
    where: StockBatchWhereUniqueInput
  }

  /**
   * StockBatch findUniqueOrThrow
   */
  export type StockBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    /**
     * Filter, which StockBatch to fetch.
     */
    where: StockBatchWhereUniqueInput
  }

  /**
   * StockBatch findFirst
   */
  export type StockBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    /**
     * Filter, which StockBatch to fetch.
     */
    where?: StockBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockBatches to fetch.
     */
    orderBy?: StockBatchOrderByWithRelationInput | StockBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockBatches.
     */
    cursor?: StockBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockBatches.
     */
    distinct?: StockBatchScalarFieldEnum | StockBatchScalarFieldEnum[]
  }

  /**
   * StockBatch findFirstOrThrow
   */
  export type StockBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    /**
     * Filter, which StockBatch to fetch.
     */
    where?: StockBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockBatches to fetch.
     */
    orderBy?: StockBatchOrderByWithRelationInput | StockBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockBatches.
     */
    cursor?: StockBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockBatches.
     */
    distinct?: StockBatchScalarFieldEnum | StockBatchScalarFieldEnum[]
  }

  /**
   * StockBatch findMany
   */
  export type StockBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    /**
     * Filter, which StockBatches to fetch.
     */
    where?: StockBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockBatches to fetch.
     */
    orderBy?: StockBatchOrderByWithRelationInput | StockBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockBatches.
     */
    cursor?: StockBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockBatches.
     */
    skip?: number
    distinct?: StockBatchScalarFieldEnum | StockBatchScalarFieldEnum[]
  }

  /**
   * StockBatch create
   */
  export type StockBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a StockBatch.
     */
    data: XOR<StockBatchCreateInput, StockBatchUncheckedCreateInput>
  }

  /**
   * StockBatch createMany
   */
  export type StockBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockBatches.
     */
    data: StockBatchCreateManyInput | StockBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockBatch update
   */
  export type StockBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a StockBatch.
     */
    data: XOR<StockBatchUpdateInput, StockBatchUncheckedUpdateInput>
    /**
     * Choose, which StockBatch to update.
     */
    where: StockBatchWhereUniqueInput
  }

  /**
   * StockBatch updateMany
   */
  export type StockBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockBatches.
     */
    data: XOR<StockBatchUpdateManyMutationInput, StockBatchUncheckedUpdateManyInput>
    /**
     * Filter which StockBatches to update
     */
    where?: StockBatchWhereInput
  }

  /**
   * StockBatch upsert
   */
  export type StockBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the StockBatch to update in case it exists.
     */
    where: StockBatchWhereUniqueInput
    /**
     * In case the StockBatch found by the `where` argument doesn't exist, create a new StockBatch with this data.
     */
    create: XOR<StockBatchCreateInput, StockBatchUncheckedCreateInput>
    /**
     * In case the StockBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockBatchUpdateInput, StockBatchUncheckedUpdateInput>
  }

  /**
   * StockBatch delete
   */
  export type StockBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    /**
     * Filter which StockBatch to delete.
     */
    where: StockBatchWhereUniqueInput
  }

  /**
   * StockBatch deleteMany
   */
  export type StockBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockBatches to delete
     */
    where?: StockBatchWhereInput
  }

  /**
   * StockBatch.Supplier
   */
  export type StockBatch$SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * StockBatch without action
   */
  export type StockBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    Supplier_Id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    Supplier_Id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    Supplier_Id: number | null
    Supplier_Name: string | null
    Contact_Name: string | null
    Contact_Phone_Number: string | null
    Contact_Email: string | null
    Notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    Supplier_Id: number | null
    Supplier_Name: string | null
    Contact_Name: string | null
    Contact_Phone_Number: string | null
    Contact_Email: string | null
    Notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    Supplier_Id: number
    Supplier_Name: number
    Contact_Name: number
    Contact_Phone_Number: number
    Contact_Email: number
    Notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    Supplier_Id?: true
  }

  export type SupplierSumAggregateInputType = {
    Supplier_Id?: true
  }

  export type SupplierMinAggregateInputType = {
    Supplier_Id?: true
    Supplier_Name?: true
    Contact_Name?: true
    Contact_Phone_Number?: true
    Contact_Email?: true
    Notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    Supplier_Id?: true
    Supplier_Name?: true
    Contact_Name?: true
    Contact_Phone_Number?: true
    Contact_Email?: true
    Notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    Supplier_Id?: true
    Supplier_Name?: true
    Contact_Name?: true
    Contact_Phone_Number?: true
    Contact_Email?: true
    Notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    Supplier_Id: number
    Supplier_Name: string
    Contact_Name: string | null
    Contact_Phone_Number: string | null
    Contact_Email: string | null
    Notes: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Supplier_Id?: boolean
    Supplier_Name?: boolean
    Contact_Name?: boolean
    Contact_Phone_Number?: boolean
    Contact_Email?: boolean
    Notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Supplied_Products?: boolean | Supplier$Supplied_ProductsArgs<ExtArgs>
    Supplied_Stock_Batches?: boolean | Supplier$Supplied_Stock_BatchesArgs<ExtArgs>
    Supplied_Purchases?: boolean | Supplier$Supplied_PurchasesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>



  export type SupplierSelectScalar = {
    Supplier_Id?: boolean
    Supplier_Name?: boolean
    Contact_Name?: boolean
    Contact_Phone_Number?: boolean
    Contact_Email?: boolean
    Notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Supplier_Id" | "Supplier_Name" | "Contact_Name" | "Contact_Phone_Number" | "Contact_Email" | "Notes" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Supplied_Products?: boolean | Supplier$Supplied_ProductsArgs<ExtArgs>
    Supplied_Stock_Batches?: boolean | Supplier$Supplied_Stock_BatchesArgs<ExtArgs>
    Supplied_Purchases?: boolean | Supplier$Supplied_PurchasesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      Supplied_Products: Prisma.$InventoryPayload<ExtArgs>[]
      Supplied_Stock_Batches: Prisma.$StockBatchPayload<ExtArgs>[]
      Supplied_Purchases: Prisma.$InventoryPurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Supplier_Id: number
      Supplier_Name: string
      Contact_Name: string | null
      Contact_Phone_Number: string | null
      Contact_Email: string | null
      Notes: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `Supplier_Id`
     * const supplierWithSupplier_IdOnly = await prisma.supplier.findMany({ select: { Supplier_Id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Supplied_Products<T extends Supplier$Supplied_ProductsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$Supplied_ProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Supplied_Stock_Batches<T extends Supplier$Supplied_Stock_BatchesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$Supplied_Stock_BatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockBatchPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Supplied_Purchases<T extends Supplier$Supplied_PurchasesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$Supplied_PurchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly Supplier_Id: FieldRef<"Supplier", 'Int'>
    readonly Supplier_Name: FieldRef<"Supplier", 'String'>
    readonly Contact_Name: FieldRef<"Supplier", 'String'>
    readonly Contact_Phone_Number: FieldRef<"Supplier", 'String'>
    readonly Contact_Email: FieldRef<"Supplier", 'String'>
    readonly Notes: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.Supplied_Products
   */
  export type Supplier$Supplied_ProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Supplier.Supplied_Stock_Batches
   */
  export type Supplier$Supplied_Stock_BatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockBatch
     */
    select?: StockBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockBatch
     */
    omit?: StockBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockBatchInclude<ExtArgs> | null
    where?: StockBatchWhereInput
    orderBy?: StockBatchOrderByWithRelationInput | StockBatchOrderByWithRelationInput[]
    cursor?: StockBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockBatchScalarFieldEnum | StockBatchScalarFieldEnum[]
  }

  /**
   * Supplier.Supplied_Purchases
   */
  export type Supplier$Supplied_PurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    where?: InventoryPurchaseWhereInput
    orderBy?: InventoryPurchaseOrderByWithRelationInput | InventoryPurchaseOrderByWithRelationInput[]
    cursor?: InventoryPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryPurchaseScalarFieldEnum | InventoryPurchaseScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    Employee_Id: number | null
    Monthly_Salary: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    Employee_Id: number | null
    Monthly_Salary: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    Employee_Id: number | null
    First_Name: string | null
    Last_Name: string | null
    Gender: string | null
    Email: string | null
    Password: string | null
    Profile_Image: string | null
    Phone_Number: string | null
    Job_Position: string | null
    Work_Shift: string | null
    Education_Details: string | null
    Work_Experience: string | null
    Monthly_Salary: number | null
    About_Employee: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    Employee_Id: number | null
    First_Name: string | null
    Last_Name: string | null
    Gender: string | null
    Email: string | null
    Password: string | null
    Profile_Image: string | null
    Phone_Number: string | null
    Job_Position: string | null
    Work_Shift: string | null
    Education_Details: string | null
    Work_Experience: string | null
    Monthly_Salary: number | null
    About_Employee: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    Employee_Id: number
    First_Name: number
    Last_Name: number
    Gender: number
    Email: number
    Password: number
    Profile_Image: number
    Phone_Number: number
    Job_Position: number
    Work_Shift: number
    Education_Details: number
    Work_Experience: number
    Monthly_Salary: number
    Address: number
    About_Employee: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    Employee_Id?: true
    Monthly_Salary?: true
  }

  export type EmployeeSumAggregateInputType = {
    Employee_Id?: true
    Monthly_Salary?: true
  }

  export type EmployeeMinAggregateInputType = {
    Employee_Id?: true
    First_Name?: true
    Last_Name?: true
    Gender?: true
    Email?: true
    Password?: true
    Profile_Image?: true
    Phone_Number?: true
    Job_Position?: true
    Work_Shift?: true
    Education_Details?: true
    Work_Experience?: true
    Monthly_Salary?: true
    About_Employee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    Employee_Id?: true
    First_Name?: true
    Last_Name?: true
    Gender?: true
    Email?: true
    Password?: true
    Profile_Image?: true
    Phone_Number?: true
    Job_Position?: true
    Work_Shift?: true
    Education_Details?: true
    Work_Experience?: true
    Monthly_Salary?: true
    About_Employee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    Employee_Id?: true
    First_Name?: true
    Last_Name?: true
    Gender?: true
    Email?: true
    Password?: true
    Profile_Image?: true
    Phone_Number?: true
    Job_Position?: true
    Work_Shift?: true
    Education_Details?: true
    Work_Experience?: true
    Monthly_Salary?: true
    Address?: true
    About_Employee?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    Employee_Id: number
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonValue
    About_Employee: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Employee_Id?: boolean
    First_Name?: boolean
    Last_Name?: boolean
    Gender?: boolean
    Email?: boolean
    Password?: boolean
    Profile_Image?: boolean
    Phone_Number?: boolean
    Job_Position?: boolean
    Work_Shift?: boolean
    Education_Details?: boolean
    Work_Experience?: boolean
    Monthly_Salary?: boolean
    Address?: boolean
    About_Employee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Inventory_Packages?: boolean | Employee$Inventory_PackagesArgs<ExtArgs>
    Withdrawal_Logs?: boolean | Employee$Withdrawal_LogsArgs<ExtArgs>
    Work_Logs?: boolean | Employee$Work_LogsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>



  export type EmployeeSelectScalar = {
    Employee_Id?: boolean
    First_Name?: boolean
    Last_Name?: boolean
    Gender?: boolean
    Email?: boolean
    Password?: boolean
    Profile_Image?: boolean
    Phone_Number?: boolean
    Job_Position?: boolean
    Work_Shift?: boolean
    Education_Details?: boolean
    Work_Experience?: boolean
    Monthly_Salary?: boolean
    Address?: boolean
    About_Employee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Employee_Id" | "First_Name" | "Last_Name" | "Gender" | "Email" | "Password" | "Profile_Image" | "Phone_Number" | "Job_Position" | "Work_Shift" | "Education_Details" | "Work_Experience" | "Monthly_Salary" | "Address" | "About_Employee" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inventory_Packages?: boolean | Employee$Inventory_PackagesArgs<ExtArgs>
    Withdrawal_Logs?: boolean | Employee$Withdrawal_LogsArgs<ExtArgs>
    Work_Logs?: boolean | Employee$Work_LogsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      Inventory_Packages: Prisma.$InventoryPurchasePayload<ExtArgs>[]
      Withdrawal_Logs: Prisma.$WithdrawalLogPayload<ExtArgs>[]
      Work_Logs: Prisma.$WorkLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Employee_Id: number
      First_Name: string
      Last_Name: string
      Gender: string
      Email: string
      Password: string
      Profile_Image: string | null
      Phone_Number: string
      Job_Position: string
      Work_Shift: string
      Education_Details: string
      Work_Experience: string
      Monthly_Salary: number
      Address: Prisma.JsonValue
      About_Employee: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `Employee_Id`
     * const employeeWithEmployee_IdOnly = await prisma.employee.findMany({ select: { Employee_Id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Inventory_Packages<T extends Employee$Inventory_PackagesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$Inventory_PackagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPurchasePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Withdrawal_Logs<T extends Employee$Withdrawal_LogsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$Withdrawal_LogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawalLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Work_Logs<T extends Employee$Work_LogsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$Work_LogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly Employee_Id: FieldRef<"Employee", 'Int'>
    readonly First_Name: FieldRef<"Employee", 'String'>
    readonly Last_Name: FieldRef<"Employee", 'String'>
    readonly Gender: FieldRef<"Employee", 'String'>
    readonly Email: FieldRef<"Employee", 'String'>
    readonly Password: FieldRef<"Employee", 'String'>
    readonly Profile_Image: FieldRef<"Employee", 'String'>
    readonly Phone_Number: FieldRef<"Employee", 'String'>
    readonly Job_Position: FieldRef<"Employee", 'String'>
    readonly Work_Shift: FieldRef<"Employee", 'String'>
    readonly Education_Details: FieldRef<"Employee", 'String'>
    readonly Work_Experience: FieldRef<"Employee", 'String'>
    readonly Monthly_Salary: FieldRef<"Employee", 'Float'>
    readonly Address: FieldRef<"Employee", 'Json'>
    readonly About_Employee: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee.Inventory_Packages
   */
  export type Employee$Inventory_PackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryPurchase
     */
    select?: InventoryPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryPurchase
     */
    omit?: InventoryPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryPurchaseInclude<ExtArgs> | null
    where?: InventoryPurchaseWhereInput
    orderBy?: InventoryPurchaseOrderByWithRelationInput | InventoryPurchaseOrderByWithRelationInput[]
    cursor?: InventoryPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryPurchaseScalarFieldEnum | InventoryPurchaseScalarFieldEnum[]
  }

  /**
   * Employee.Withdrawal_Logs
   */
  export type Employee$Withdrawal_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WithdrawalLog
     */
    select?: WithdrawalLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WithdrawalLog
     */
    omit?: WithdrawalLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WithdrawalLogInclude<ExtArgs> | null
    where?: WithdrawalLogWhereInput
    orderBy?: WithdrawalLogOrderByWithRelationInput | WithdrawalLogOrderByWithRelationInput[]
    cursor?: WithdrawalLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawalLogScalarFieldEnum | WithdrawalLogScalarFieldEnum[]
  }

  /**
   * Employee.Work_Logs
   */
  export type Employee$Work_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    where?: WorkLogWhereInput
    orderBy?: WorkLogOrderByWithRelationInput | WorkLogOrderByWithRelationInput[]
    cursor?: WorkLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkLogScalarFieldEnum | WorkLogScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model WorkLog
   */

  export type AggregateWorkLog = {
    _count: WorkLogCountAggregateOutputType | null
    _avg: WorkLogAvgAggregateOutputType | null
    _sum: WorkLogSumAggregateOutputType | null
    _min: WorkLogMinAggregateOutputType | null
    _max: WorkLogMaxAggregateOutputType | null
  }

  export type WorkLogAvgAggregateOutputType = {
    WorkLog_Id: number | null
    Employee_Id: number | null
  }

  export type WorkLogSumAggregateOutputType = {
    WorkLog_Id: number | null
    Employee_Id: number | null
  }

  export type WorkLogMinAggregateOutputType = {
    WorkLog_Id: number | null
    Employee_Id: number | null
    Login_Time: Date | null
    Logout_Time: Date | null
  }

  export type WorkLogMaxAggregateOutputType = {
    WorkLog_Id: number | null
    Employee_Id: number | null
    Login_Time: Date | null
    Logout_Time: Date | null
  }

  export type WorkLogCountAggregateOutputType = {
    WorkLog_Id: number
    Employee_Id: number
    Login_Time: number
    Logout_Time: number
    _all: number
  }


  export type WorkLogAvgAggregateInputType = {
    WorkLog_Id?: true
    Employee_Id?: true
  }

  export type WorkLogSumAggregateInputType = {
    WorkLog_Id?: true
    Employee_Id?: true
  }

  export type WorkLogMinAggregateInputType = {
    WorkLog_Id?: true
    Employee_Id?: true
    Login_Time?: true
    Logout_Time?: true
  }

  export type WorkLogMaxAggregateInputType = {
    WorkLog_Id?: true
    Employee_Id?: true
    Login_Time?: true
    Logout_Time?: true
  }

  export type WorkLogCountAggregateInputType = {
    WorkLog_Id?: true
    Employee_Id?: true
    Login_Time?: true
    Logout_Time?: true
    _all?: true
  }

  export type WorkLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkLog to aggregate.
     */
    where?: WorkLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkLogs to fetch.
     */
    orderBy?: WorkLogOrderByWithRelationInput | WorkLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkLogs
    **/
    _count?: true | WorkLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkLogMaxAggregateInputType
  }

  export type GetWorkLogAggregateType<T extends WorkLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkLog[P]>
      : GetScalarType<T[P], AggregateWorkLog[P]>
  }




  export type WorkLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkLogWhereInput
    orderBy?: WorkLogOrderByWithAggregationInput | WorkLogOrderByWithAggregationInput[]
    by: WorkLogScalarFieldEnum[] | WorkLogScalarFieldEnum
    having?: WorkLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkLogCountAggregateInputType | true
    _avg?: WorkLogAvgAggregateInputType
    _sum?: WorkLogSumAggregateInputType
    _min?: WorkLogMinAggregateInputType
    _max?: WorkLogMaxAggregateInputType
  }

  export type WorkLogGroupByOutputType = {
    WorkLog_Id: number
    Employee_Id: number
    Login_Time: Date
    Logout_Time: Date | null
    _count: WorkLogCountAggregateOutputType | null
    _avg: WorkLogAvgAggregateOutputType | null
    _sum: WorkLogSumAggregateOutputType | null
    _min: WorkLogMinAggregateOutputType | null
    _max: WorkLogMaxAggregateOutputType | null
  }

  type GetWorkLogGroupByPayload<T extends WorkLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkLogGroupByOutputType[P]>
            : GetScalarType<T[P], WorkLogGroupByOutputType[P]>
        }
      >
    >


  export type WorkLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    WorkLog_Id?: boolean
    Employee_Id?: boolean
    Login_Time?: boolean
    Logout_Time?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workLog"]>



  export type WorkLogSelectScalar = {
    WorkLog_Id?: boolean
    Employee_Id?: boolean
    Login_Time?: boolean
    Logout_Time?: boolean
  }

  export type WorkLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"WorkLog_Id" | "Employee_Id" | "Login_Time" | "Logout_Time", ExtArgs["result"]["workLog"]>
  export type WorkLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $WorkLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkLog"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      WorkLog_Id: number
      Employee_Id: number
      Login_Time: Date
      Logout_Time: Date | null
    }, ExtArgs["result"]["workLog"]>
    composites: {}
  }

  type WorkLogGetPayload<S extends boolean | null | undefined | WorkLogDefaultArgs> = $Result.GetResult<Prisma.$WorkLogPayload, S>

  type WorkLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkLogCountAggregateInputType | true
    }

  export interface WorkLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkLog'], meta: { name: 'WorkLog' } }
    /**
     * Find zero or one WorkLog that matches the filter.
     * @param {WorkLogFindUniqueArgs} args - Arguments to find a WorkLog
     * @example
     * // Get one WorkLog
     * const workLog = await prisma.workLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkLogFindUniqueArgs>(args: SelectSubset<T, WorkLogFindUniqueArgs<ExtArgs>>): Prisma__WorkLogClient<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WorkLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkLogFindUniqueOrThrowArgs} args - Arguments to find a WorkLog
     * @example
     * // Get one WorkLog
     * const workLog = await prisma.workLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkLogClient<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WorkLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkLogFindFirstArgs} args - Arguments to find a WorkLog
     * @example
     * // Get one WorkLog
     * const workLog = await prisma.workLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkLogFindFirstArgs>(args?: SelectSubset<T, WorkLogFindFirstArgs<ExtArgs>>): Prisma__WorkLogClient<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WorkLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkLogFindFirstOrThrowArgs} args - Arguments to find a WorkLog
     * @example
     * // Get one WorkLog
     * const workLog = await prisma.workLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkLogClient<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WorkLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkLogs
     * const workLogs = await prisma.workLog.findMany()
     * 
     * // Get first 10 WorkLogs
     * const workLogs = await prisma.workLog.findMany({ take: 10 })
     * 
     * // Only select the `WorkLog_Id`
     * const workLogWithWorkLog_IdOnly = await prisma.workLog.findMany({ select: { WorkLog_Id: true } })
     * 
     */
    findMany<T extends WorkLogFindManyArgs>(args?: SelectSubset<T, WorkLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WorkLog.
     * @param {WorkLogCreateArgs} args - Arguments to create a WorkLog.
     * @example
     * // Create one WorkLog
     * const WorkLog = await prisma.workLog.create({
     *   data: {
     *     // ... data to create a WorkLog
     *   }
     * })
     * 
     */
    create<T extends WorkLogCreateArgs>(args: SelectSubset<T, WorkLogCreateArgs<ExtArgs>>): Prisma__WorkLogClient<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WorkLogs.
     * @param {WorkLogCreateManyArgs} args - Arguments to create many WorkLogs.
     * @example
     * // Create many WorkLogs
     * const workLog = await prisma.workLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkLogCreateManyArgs>(args?: SelectSubset<T, WorkLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkLog.
     * @param {WorkLogDeleteArgs} args - Arguments to delete one WorkLog.
     * @example
     * // Delete one WorkLog
     * const WorkLog = await prisma.workLog.delete({
     *   where: {
     *     // ... filter to delete one WorkLog
     *   }
     * })
     * 
     */
    delete<T extends WorkLogDeleteArgs>(args: SelectSubset<T, WorkLogDeleteArgs<ExtArgs>>): Prisma__WorkLogClient<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WorkLog.
     * @param {WorkLogUpdateArgs} args - Arguments to update one WorkLog.
     * @example
     * // Update one WorkLog
     * const workLog = await prisma.workLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkLogUpdateArgs>(args: SelectSubset<T, WorkLogUpdateArgs<ExtArgs>>): Prisma__WorkLogClient<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WorkLogs.
     * @param {WorkLogDeleteManyArgs} args - Arguments to filter WorkLogs to delete.
     * @example
     * // Delete a few WorkLogs
     * const { count } = await prisma.workLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkLogDeleteManyArgs>(args?: SelectSubset<T, WorkLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkLogs
     * const workLog = await prisma.workLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkLogUpdateManyArgs>(args: SelectSubset<T, WorkLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkLog.
     * @param {WorkLogUpsertArgs} args - Arguments to update or create a WorkLog.
     * @example
     * // Update or create a WorkLog
     * const workLog = await prisma.workLog.upsert({
     *   create: {
     *     // ... data to create a WorkLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkLog we want to update
     *   }
     * })
     */
    upsert<T extends WorkLogUpsertArgs>(args: SelectSubset<T, WorkLogUpsertArgs<ExtArgs>>): Prisma__WorkLogClient<$Result.GetResult<Prisma.$WorkLogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WorkLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkLogCountArgs} args - Arguments to filter WorkLogs to count.
     * @example
     * // Count the number of WorkLogs
     * const count = await prisma.workLog.count({
     *   where: {
     *     // ... the filter for the WorkLogs we want to count
     *   }
     * })
    **/
    count<T extends WorkLogCountArgs>(
      args?: Subset<T, WorkLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkLogAggregateArgs>(args: Subset<T, WorkLogAggregateArgs>): Prisma.PrismaPromise<GetWorkLogAggregateType<T>>

    /**
     * Group by WorkLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkLogGroupByArgs['orderBy'] }
        : { orderBy?: WorkLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkLog model
   */
  readonly fields: WorkLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkLog model
   */ 
  interface WorkLogFieldRefs {
    readonly WorkLog_Id: FieldRef<"WorkLog", 'Int'>
    readonly Employee_Id: FieldRef<"WorkLog", 'Int'>
    readonly Login_Time: FieldRef<"WorkLog", 'DateTime'>
    readonly Logout_Time: FieldRef<"WorkLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkLog findUnique
   */
  export type WorkLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkLog to fetch.
     */
    where: WorkLogWhereUniqueInput
  }

  /**
   * WorkLog findUniqueOrThrow
   */
  export type WorkLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkLog to fetch.
     */
    where: WorkLogWhereUniqueInput
  }

  /**
   * WorkLog findFirst
   */
  export type WorkLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkLog to fetch.
     */
    where?: WorkLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkLogs to fetch.
     */
    orderBy?: WorkLogOrderByWithRelationInput | WorkLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkLogs.
     */
    cursor?: WorkLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkLogs.
     */
    distinct?: WorkLogScalarFieldEnum | WorkLogScalarFieldEnum[]
  }

  /**
   * WorkLog findFirstOrThrow
   */
  export type WorkLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkLog to fetch.
     */
    where?: WorkLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkLogs to fetch.
     */
    orderBy?: WorkLogOrderByWithRelationInput | WorkLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkLogs.
     */
    cursor?: WorkLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkLogs.
     */
    distinct?: WorkLogScalarFieldEnum | WorkLogScalarFieldEnum[]
  }

  /**
   * WorkLog findMany
   */
  export type WorkLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkLogs to fetch.
     */
    where?: WorkLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkLogs to fetch.
     */
    orderBy?: WorkLogOrderByWithRelationInput | WorkLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkLogs.
     */
    cursor?: WorkLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkLogs.
     */
    skip?: number
    distinct?: WorkLogScalarFieldEnum | WorkLogScalarFieldEnum[]
  }

  /**
   * WorkLog create
   */
  export type WorkLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkLog.
     */
    data: XOR<WorkLogCreateInput, WorkLogUncheckedCreateInput>
  }

  /**
   * WorkLog createMany
   */
  export type WorkLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkLogs.
     */
    data: WorkLogCreateManyInput | WorkLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkLog update
   */
  export type WorkLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkLog.
     */
    data: XOR<WorkLogUpdateInput, WorkLogUncheckedUpdateInput>
    /**
     * Choose, which WorkLog to update.
     */
    where: WorkLogWhereUniqueInput
  }

  /**
   * WorkLog updateMany
   */
  export type WorkLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkLogs.
     */
    data: XOR<WorkLogUpdateManyMutationInput, WorkLogUncheckedUpdateManyInput>
    /**
     * Filter which WorkLogs to update
     */
    where?: WorkLogWhereInput
  }

  /**
   * WorkLog upsert
   */
  export type WorkLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkLog to update in case it exists.
     */
    where: WorkLogWhereUniqueInput
    /**
     * In case the WorkLog found by the `where` argument doesn't exist, create a new WorkLog with this data.
     */
    create: XOR<WorkLogCreateInput, WorkLogUncheckedCreateInput>
    /**
     * In case the WorkLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkLogUpdateInput, WorkLogUncheckedUpdateInput>
  }

  /**
   * WorkLog delete
   */
  export type WorkLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
    /**
     * Filter which WorkLog to delete.
     */
    where: WorkLogWhereUniqueInput
  }

  /**
   * WorkLog deleteMany
   */
  export type WorkLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkLogs to delete
     */
    where?: WorkLogWhereInput
  }

  /**
   * WorkLog without action
   */
  export type WorkLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkLog
     */
    select?: WorkLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkLog
     */
    omit?: WorkLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const InventoryScalarFieldEnum: {
    Inventory_Id: 'Inventory_Id',
    Product_Name: 'Product_Name',
    Product_Category: 'Product_Category',
    Product_Description: 'Product_Description',
    Is_Discontinued: 'Is_Discontinued',
    Stock_Quantity: 'Stock_Quantity',
    Reorder_Threshold: 'Reorder_Threshold',
    Total_Value: 'Total_Value',
    Unit_Of_Measurement: 'Unit_Of_Measurement',
    Unit_Price: 'Unit_Price',
    Stock_Status: 'Stock_Status',
    Storage_Location: 'Storage_Location',
    Expiry_Date: 'Expiry_Date',
    Initial_Stock_Quantity: 'Initial_Stock_Quantity',
    Supplier_Id: 'Supplier_Id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const WithdrawalLogScalarFieldEnum: {
    WithdrawalLog_Id: 'WithdrawalLog_Id',
    Inventory_Id: 'Inventory_Id',
    Employee_Id: 'Employee_Id',
    Withdrawal_Reason: 'Withdrawal_Reason',
    Quantity_Withdrawn: 'Quantity_Withdrawn',
    Date_Withdrawn: 'Date_Withdrawn',
    updatedAt: 'updatedAt'
  };

  export type WithdrawalLogScalarFieldEnum = (typeof WithdrawalLogScalarFieldEnum)[keyof typeof WithdrawalLogScalarFieldEnum]


  export const InventoryPurchaseScalarFieldEnum: {
    Purchase_Id: 'Purchase_Id',
    Inventory_Id: 'Inventory_Id',
    Employee_Id: 'Employee_Id',
    Supplier_Id: 'Supplier_Id',
    Purchase_Date: 'Purchase_Date',
    Quantity_Purchased: 'Quantity_Purchased',
    Total_Cost: 'Total_Cost',
    Unit_Price: 'Unit_Price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryPurchaseScalarFieldEnum = (typeof InventoryPurchaseScalarFieldEnum)[keyof typeof InventoryPurchaseScalarFieldEnum]


  export const StockBatchScalarFieldEnum: {
    StockBatch_Id: 'StockBatch_Id',
    Batch_Number: 'Batch_Number',
    Inventory_Id: 'Inventory_Id',
    Supplier_Id: 'Supplier_Id',
    Purchase_Date: 'Purchase_Date',
    Quantity_Purchased: 'Quantity_Purchased',
    Unit_Price: 'Unit_Price',
    Expiry_Date: 'Expiry_Date',
    Remaining_Quantity: 'Remaining_Quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockBatchScalarFieldEnum = (typeof StockBatchScalarFieldEnum)[keyof typeof StockBatchScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    Supplier_Id: 'Supplier_Id',
    Supplier_Name: 'Supplier_Name',
    Contact_Name: 'Contact_Name',
    Contact_Phone_Number: 'Contact_Phone_Number',
    Contact_Email: 'Contact_Email',
    Notes: 'Notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    Employee_Id: 'Employee_Id',
    First_Name: 'First_Name',
    Last_Name: 'Last_Name',
    Gender: 'Gender',
    Email: 'Email',
    Password: 'Password',
    Profile_Image: 'Profile_Image',
    Phone_Number: 'Phone_Number',
    Job_Position: 'Job_Position',
    Work_Shift: 'Work_Shift',
    Education_Details: 'Education_Details',
    Work_Experience: 'Work_Experience',
    Monthly_Salary: 'Monthly_Salary',
    Address: 'Address',
    About_Employee: 'About_Employee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const WorkLogScalarFieldEnum: {
    WorkLog_Id: 'WorkLog_Id',
    Employee_Id: 'Employee_Id',
    Login_Time: 'Login_Time',
    Logout_Time: 'Logout_Time'
  };

  export type WorkLogScalarFieldEnum = (typeof WorkLogScalarFieldEnum)[keyof typeof WorkLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const InventoryOrderByRelevanceFieldEnum: {
    Product_Name: 'Product_Name',
    Product_Category: 'Product_Category',
    Product_Description: 'Product_Description',
    Unit_Of_Measurement: 'Unit_Of_Measurement',
    Stock_Status: 'Stock_Status',
    Storage_Location: 'Storage_Location'
  };

  export type InventoryOrderByRelevanceFieldEnum = (typeof InventoryOrderByRelevanceFieldEnum)[keyof typeof InventoryOrderByRelevanceFieldEnum]


  export const WithdrawalLogOrderByRelevanceFieldEnum: {
    Withdrawal_Reason: 'Withdrawal_Reason'
  };

  export type WithdrawalLogOrderByRelevanceFieldEnum = (typeof WithdrawalLogOrderByRelevanceFieldEnum)[keyof typeof WithdrawalLogOrderByRelevanceFieldEnum]


  export const StockBatchOrderByRelevanceFieldEnum: {
    Batch_Number: 'Batch_Number'
  };

  export type StockBatchOrderByRelevanceFieldEnum = (typeof StockBatchOrderByRelevanceFieldEnum)[keyof typeof StockBatchOrderByRelevanceFieldEnum]


  export const SupplierOrderByRelevanceFieldEnum: {
    Supplier_Name: 'Supplier_Name',
    Contact_Name: 'Contact_Name',
    Contact_Phone_Number: 'Contact_Phone_Number',
    Contact_Email: 'Contact_Email',
    Notes: 'Notes'
  };

  export type SupplierOrderByRelevanceFieldEnum = (typeof SupplierOrderByRelevanceFieldEnum)[keyof typeof SupplierOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const EmployeeOrderByRelevanceFieldEnum: {
    First_Name: 'First_Name',
    Last_Name: 'Last_Name',
    Gender: 'Gender',
    Email: 'Email',
    Password: 'Password',
    Profile_Image: 'Profile_Image',
    Phone_Number: 'Phone_Number',
    Job_Position: 'Job_Position',
    Work_Shift: 'Work_Shift',
    Education_Details: 'Education_Details',
    Work_Experience: 'Work_Experience',
    About_Employee: 'About_Employee'
  };

  export type EmployeeOrderByRelevanceFieldEnum = (typeof EmployeeOrderByRelevanceFieldEnum)[keyof typeof EmployeeOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    Inventory_Id?: IntFilter<"Inventory"> | number
    Product_Name?: StringFilter<"Inventory"> | string
    Product_Category?: StringFilter<"Inventory"> | string
    Product_Description?: StringNullableFilter<"Inventory"> | string | null
    Is_Discontinued?: BoolFilter<"Inventory"> | boolean
    Stock_Quantity?: IntFilter<"Inventory"> | number
    Reorder_Threshold?: IntNullableFilter<"Inventory"> | number | null
    Total_Value?: FloatNullableFilter<"Inventory"> | number | null
    Unit_Of_Measurement?: StringFilter<"Inventory"> | string
    Unit_Price?: FloatNullableFilter<"Inventory"> | number | null
    Stock_Status?: StringNullableFilter<"Inventory"> | string | null
    Storage_Location?: StringNullableFilter<"Inventory"> | string | null
    Expiry_Date?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    Initial_Stock_Quantity?: IntNullableFilter<"Inventory"> | number | null
    Supplier_Id?: IntNullableFilter<"Inventory"> | number | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    Supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    Inventory_Purchases?: InventoryPurchaseListRelationFilter
    Withdrawal_Logs?: WithdrawalLogListRelationFilter
    Stock_Batches?: StockBatchListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    Inventory_Id?: SortOrder
    Product_Name?: SortOrder
    Product_Category?: SortOrder
    Product_Description?: SortOrderInput | SortOrder
    Is_Discontinued?: SortOrder
    Stock_Quantity?: SortOrder
    Reorder_Threshold?: SortOrderInput | SortOrder
    Total_Value?: SortOrderInput | SortOrder
    Unit_Of_Measurement?: SortOrder
    Unit_Price?: SortOrderInput | SortOrder
    Stock_Status?: SortOrderInput | SortOrder
    Storage_Location?: SortOrderInput | SortOrder
    Expiry_Date?: SortOrderInput | SortOrder
    Initial_Stock_Quantity?: SortOrderInput | SortOrder
    Supplier_Id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Supplier?: SupplierOrderByWithRelationInput
    Inventory_Purchases?: InventoryPurchaseOrderByRelationAggregateInput
    Withdrawal_Logs?: WithdrawalLogOrderByRelationAggregateInput
    Stock_Batches?: StockBatchOrderByRelationAggregateInput
    _relevance?: InventoryOrderByRelevanceInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    Inventory_Id?: number
    Product_Name?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    Product_Category?: StringFilter<"Inventory"> | string
    Product_Description?: StringNullableFilter<"Inventory"> | string | null
    Is_Discontinued?: BoolFilter<"Inventory"> | boolean
    Stock_Quantity?: IntFilter<"Inventory"> | number
    Reorder_Threshold?: IntNullableFilter<"Inventory"> | number | null
    Total_Value?: FloatNullableFilter<"Inventory"> | number | null
    Unit_Of_Measurement?: StringFilter<"Inventory"> | string
    Unit_Price?: FloatNullableFilter<"Inventory"> | number | null
    Stock_Status?: StringNullableFilter<"Inventory"> | string | null
    Storage_Location?: StringNullableFilter<"Inventory"> | string | null
    Expiry_Date?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    Initial_Stock_Quantity?: IntNullableFilter<"Inventory"> | number | null
    Supplier_Id?: IntNullableFilter<"Inventory"> | number | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    Supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    Inventory_Purchases?: InventoryPurchaseListRelationFilter
    Withdrawal_Logs?: WithdrawalLogListRelationFilter
    Stock_Batches?: StockBatchListRelationFilter
  }, "Inventory_Id" | "Product_Name">

  export type InventoryOrderByWithAggregationInput = {
    Inventory_Id?: SortOrder
    Product_Name?: SortOrder
    Product_Category?: SortOrder
    Product_Description?: SortOrderInput | SortOrder
    Is_Discontinued?: SortOrder
    Stock_Quantity?: SortOrder
    Reorder_Threshold?: SortOrderInput | SortOrder
    Total_Value?: SortOrderInput | SortOrder
    Unit_Of_Measurement?: SortOrder
    Unit_Price?: SortOrderInput | SortOrder
    Stock_Status?: SortOrderInput | SortOrder
    Storage_Location?: SortOrderInput | SortOrder
    Expiry_Date?: SortOrderInput | SortOrder
    Initial_Stock_Quantity?: SortOrderInput | SortOrder
    Supplier_Id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    Inventory_Id?: IntWithAggregatesFilter<"Inventory"> | number
    Product_Name?: StringWithAggregatesFilter<"Inventory"> | string
    Product_Category?: StringWithAggregatesFilter<"Inventory"> | string
    Product_Description?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    Is_Discontinued?: BoolWithAggregatesFilter<"Inventory"> | boolean
    Stock_Quantity?: IntWithAggregatesFilter<"Inventory"> | number
    Reorder_Threshold?: IntNullableWithAggregatesFilter<"Inventory"> | number | null
    Total_Value?: FloatNullableWithAggregatesFilter<"Inventory"> | number | null
    Unit_Of_Measurement?: StringWithAggregatesFilter<"Inventory"> | string
    Unit_Price?: FloatNullableWithAggregatesFilter<"Inventory"> | number | null
    Stock_Status?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    Storage_Location?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    Expiry_Date?: DateTimeNullableWithAggregatesFilter<"Inventory"> | Date | string | null
    Initial_Stock_Quantity?: IntNullableWithAggregatesFilter<"Inventory"> | number | null
    Supplier_Id?: IntNullableWithAggregatesFilter<"Inventory"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Inventory"> | Date | string | null
  }

  export type WithdrawalLogWhereInput = {
    AND?: WithdrawalLogWhereInput | WithdrawalLogWhereInput[]
    OR?: WithdrawalLogWhereInput[]
    NOT?: WithdrawalLogWhereInput | WithdrawalLogWhereInput[]
    WithdrawalLog_Id?: IntFilter<"WithdrawalLog"> | number
    Inventory_Id?: IntFilter<"WithdrawalLog"> | number
    Employee_Id?: IntNullableFilter<"WithdrawalLog"> | number | null
    Withdrawal_Reason?: StringNullableFilter<"WithdrawalLog"> | string | null
    Quantity_Withdrawn?: IntFilter<"WithdrawalLog"> | number
    Date_Withdrawn?: DateTimeFilter<"WithdrawalLog"> | Date | string
    updatedAt?: DateTimeNullableFilter<"WithdrawalLog"> | Date | string | null
    Inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    Employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }

  export type WithdrawalLogOrderByWithRelationInput = {
    WithdrawalLog_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrderInput | SortOrder
    Withdrawal_Reason?: SortOrderInput | SortOrder
    Quantity_Withdrawn?: SortOrder
    Date_Withdrawn?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Inventory?: InventoryOrderByWithRelationInput
    Employee?: EmployeeOrderByWithRelationInput
    _relevance?: WithdrawalLogOrderByRelevanceInput
  }

  export type WithdrawalLogWhereUniqueInput = Prisma.AtLeast<{
    WithdrawalLog_Id?: number
    AND?: WithdrawalLogWhereInput | WithdrawalLogWhereInput[]
    OR?: WithdrawalLogWhereInput[]
    NOT?: WithdrawalLogWhereInput | WithdrawalLogWhereInput[]
    Inventory_Id?: IntFilter<"WithdrawalLog"> | number
    Employee_Id?: IntNullableFilter<"WithdrawalLog"> | number | null
    Withdrawal_Reason?: StringNullableFilter<"WithdrawalLog"> | string | null
    Quantity_Withdrawn?: IntFilter<"WithdrawalLog"> | number
    Date_Withdrawn?: DateTimeFilter<"WithdrawalLog"> | Date | string
    updatedAt?: DateTimeNullableFilter<"WithdrawalLog"> | Date | string | null
    Inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    Employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }, "WithdrawalLog_Id">

  export type WithdrawalLogOrderByWithAggregationInput = {
    WithdrawalLog_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrderInput | SortOrder
    Withdrawal_Reason?: SortOrderInput | SortOrder
    Quantity_Withdrawn?: SortOrder
    Date_Withdrawn?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: WithdrawalLogCountOrderByAggregateInput
    _avg?: WithdrawalLogAvgOrderByAggregateInput
    _max?: WithdrawalLogMaxOrderByAggregateInput
    _min?: WithdrawalLogMinOrderByAggregateInput
    _sum?: WithdrawalLogSumOrderByAggregateInput
  }

  export type WithdrawalLogScalarWhereWithAggregatesInput = {
    AND?: WithdrawalLogScalarWhereWithAggregatesInput | WithdrawalLogScalarWhereWithAggregatesInput[]
    OR?: WithdrawalLogScalarWhereWithAggregatesInput[]
    NOT?: WithdrawalLogScalarWhereWithAggregatesInput | WithdrawalLogScalarWhereWithAggregatesInput[]
    WithdrawalLog_Id?: IntWithAggregatesFilter<"WithdrawalLog"> | number
    Inventory_Id?: IntWithAggregatesFilter<"WithdrawalLog"> | number
    Employee_Id?: IntNullableWithAggregatesFilter<"WithdrawalLog"> | number | null
    Withdrawal_Reason?: StringNullableWithAggregatesFilter<"WithdrawalLog"> | string | null
    Quantity_Withdrawn?: IntWithAggregatesFilter<"WithdrawalLog"> | number
    Date_Withdrawn?: DateTimeWithAggregatesFilter<"WithdrawalLog"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"WithdrawalLog"> | Date | string | null
  }

  export type InventoryPurchaseWhereInput = {
    AND?: InventoryPurchaseWhereInput | InventoryPurchaseWhereInput[]
    OR?: InventoryPurchaseWhereInput[]
    NOT?: InventoryPurchaseWhereInput | InventoryPurchaseWhereInput[]
    Purchase_Id?: IntFilter<"InventoryPurchase"> | number
    Inventory_Id?: IntFilter<"InventoryPurchase"> | number
    Employee_Id?: IntNullableFilter<"InventoryPurchase"> | number | null
    Supplier_Id?: IntNullableFilter<"InventoryPurchase"> | number | null
    Purchase_Date?: DateTimeFilter<"InventoryPurchase"> | Date | string
    Quantity_Purchased?: IntFilter<"InventoryPurchase"> | number
    Total_Cost?: FloatNullableFilter<"InventoryPurchase"> | number | null
    Unit_Price?: FloatNullableFilter<"InventoryPurchase"> | number | null
    createdAt?: DateTimeFilter<"InventoryPurchase"> | Date | string
    updatedAt?: DateTimeNullableFilter<"InventoryPurchase"> | Date | string | null
    Inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    Supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    Employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }

  export type InventoryPurchaseOrderByWithRelationInput = {
    Purchase_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrderInput | SortOrder
    Supplier_Id?: SortOrderInput | SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Total_Cost?: SortOrderInput | SortOrder
    Unit_Price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Inventory?: InventoryOrderByWithRelationInput
    Supplier?: SupplierOrderByWithRelationInput
    Employee?: EmployeeOrderByWithRelationInput
  }

  export type InventoryPurchaseWhereUniqueInput = Prisma.AtLeast<{
    Purchase_Id?: number
    AND?: InventoryPurchaseWhereInput | InventoryPurchaseWhereInput[]
    OR?: InventoryPurchaseWhereInput[]
    NOT?: InventoryPurchaseWhereInput | InventoryPurchaseWhereInput[]
    Inventory_Id?: IntFilter<"InventoryPurchase"> | number
    Employee_Id?: IntNullableFilter<"InventoryPurchase"> | number | null
    Supplier_Id?: IntNullableFilter<"InventoryPurchase"> | number | null
    Purchase_Date?: DateTimeFilter<"InventoryPurchase"> | Date | string
    Quantity_Purchased?: IntFilter<"InventoryPurchase"> | number
    Total_Cost?: FloatNullableFilter<"InventoryPurchase"> | number | null
    Unit_Price?: FloatNullableFilter<"InventoryPurchase"> | number | null
    createdAt?: DateTimeFilter<"InventoryPurchase"> | Date | string
    updatedAt?: DateTimeNullableFilter<"InventoryPurchase"> | Date | string | null
    Inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    Supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    Employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }, "Purchase_Id">

  export type InventoryPurchaseOrderByWithAggregationInput = {
    Purchase_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrderInput | SortOrder
    Supplier_Id?: SortOrderInput | SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Total_Cost?: SortOrderInput | SortOrder
    Unit_Price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: InventoryPurchaseCountOrderByAggregateInput
    _avg?: InventoryPurchaseAvgOrderByAggregateInput
    _max?: InventoryPurchaseMaxOrderByAggregateInput
    _min?: InventoryPurchaseMinOrderByAggregateInput
    _sum?: InventoryPurchaseSumOrderByAggregateInput
  }

  export type InventoryPurchaseScalarWhereWithAggregatesInput = {
    AND?: InventoryPurchaseScalarWhereWithAggregatesInput | InventoryPurchaseScalarWhereWithAggregatesInput[]
    OR?: InventoryPurchaseScalarWhereWithAggregatesInput[]
    NOT?: InventoryPurchaseScalarWhereWithAggregatesInput | InventoryPurchaseScalarWhereWithAggregatesInput[]
    Purchase_Id?: IntWithAggregatesFilter<"InventoryPurchase"> | number
    Inventory_Id?: IntWithAggregatesFilter<"InventoryPurchase"> | number
    Employee_Id?: IntNullableWithAggregatesFilter<"InventoryPurchase"> | number | null
    Supplier_Id?: IntNullableWithAggregatesFilter<"InventoryPurchase"> | number | null
    Purchase_Date?: DateTimeWithAggregatesFilter<"InventoryPurchase"> | Date | string
    Quantity_Purchased?: IntWithAggregatesFilter<"InventoryPurchase"> | number
    Total_Cost?: FloatNullableWithAggregatesFilter<"InventoryPurchase"> | number | null
    Unit_Price?: FloatNullableWithAggregatesFilter<"InventoryPurchase"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryPurchase"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"InventoryPurchase"> | Date | string | null
  }

  export type StockBatchWhereInput = {
    AND?: StockBatchWhereInput | StockBatchWhereInput[]
    OR?: StockBatchWhereInput[]
    NOT?: StockBatchWhereInput | StockBatchWhereInput[]
    StockBatch_Id?: IntFilter<"StockBatch"> | number
    Batch_Number?: StringFilter<"StockBatch"> | string
    Inventory_Id?: IntFilter<"StockBatch"> | number
    Supplier_Id?: IntNullableFilter<"StockBatch"> | number | null
    Purchase_Date?: DateTimeFilter<"StockBatch"> | Date | string
    Quantity_Purchased?: IntFilter<"StockBatch"> | number
    Unit_Price?: FloatFilter<"StockBatch"> | number
    Expiry_Date?: DateTimeNullableFilter<"StockBatch"> | Date | string | null
    Remaining_Quantity?: IntFilter<"StockBatch"> | number
    createdAt?: DateTimeFilter<"StockBatch"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockBatch"> | Date | string | null
    Inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    Supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
  }

  export type StockBatchOrderByWithRelationInput = {
    StockBatch_Id?: SortOrder
    Batch_Number?: SortOrder
    Inventory_Id?: SortOrder
    Supplier_Id?: SortOrderInput | SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Unit_Price?: SortOrder
    Expiry_Date?: SortOrderInput | SortOrder
    Remaining_Quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Inventory?: InventoryOrderByWithRelationInput
    Supplier?: SupplierOrderByWithRelationInput
    _relevance?: StockBatchOrderByRelevanceInput
  }

  export type StockBatchWhereUniqueInput = Prisma.AtLeast<{
    StockBatch_Id?: number
    Batch_Number?: string
    AND?: StockBatchWhereInput | StockBatchWhereInput[]
    OR?: StockBatchWhereInput[]
    NOT?: StockBatchWhereInput | StockBatchWhereInput[]
    Inventory_Id?: IntFilter<"StockBatch"> | number
    Supplier_Id?: IntNullableFilter<"StockBatch"> | number | null
    Purchase_Date?: DateTimeFilter<"StockBatch"> | Date | string
    Quantity_Purchased?: IntFilter<"StockBatch"> | number
    Unit_Price?: FloatFilter<"StockBatch"> | number
    Expiry_Date?: DateTimeNullableFilter<"StockBatch"> | Date | string | null
    Remaining_Quantity?: IntFilter<"StockBatch"> | number
    createdAt?: DateTimeFilter<"StockBatch"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockBatch"> | Date | string | null
    Inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    Supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
  }, "StockBatch_Id" | "Batch_Number">

  export type StockBatchOrderByWithAggregationInput = {
    StockBatch_Id?: SortOrder
    Batch_Number?: SortOrder
    Inventory_Id?: SortOrder
    Supplier_Id?: SortOrderInput | SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Unit_Price?: SortOrder
    Expiry_Date?: SortOrderInput | SortOrder
    Remaining_Quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StockBatchCountOrderByAggregateInput
    _avg?: StockBatchAvgOrderByAggregateInput
    _max?: StockBatchMaxOrderByAggregateInput
    _min?: StockBatchMinOrderByAggregateInput
    _sum?: StockBatchSumOrderByAggregateInput
  }

  export type StockBatchScalarWhereWithAggregatesInput = {
    AND?: StockBatchScalarWhereWithAggregatesInput | StockBatchScalarWhereWithAggregatesInput[]
    OR?: StockBatchScalarWhereWithAggregatesInput[]
    NOT?: StockBatchScalarWhereWithAggregatesInput | StockBatchScalarWhereWithAggregatesInput[]
    StockBatch_Id?: IntWithAggregatesFilter<"StockBatch"> | number
    Batch_Number?: StringWithAggregatesFilter<"StockBatch"> | string
    Inventory_Id?: IntWithAggregatesFilter<"StockBatch"> | number
    Supplier_Id?: IntNullableWithAggregatesFilter<"StockBatch"> | number | null
    Purchase_Date?: DateTimeWithAggregatesFilter<"StockBatch"> | Date | string
    Quantity_Purchased?: IntWithAggregatesFilter<"StockBatch"> | number
    Unit_Price?: FloatWithAggregatesFilter<"StockBatch"> | number
    Expiry_Date?: DateTimeNullableWithAggregatesFilter<"StockBatch"> | Date | string | null
    Remaining_Quantity?: IntWithAggregatesFilter<"StockBatch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StockBatch"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"StockBatch"> | Date | string | null
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    Supplier_Id?: IntFilter<"Supplier"> | number
    Supplier_Name?: StringFilter<"Supplier"> | string
    Contact_Name?: StringNullableFilter<"Supplier"> | string | null
    Contact_Phone_Number?: StringNullableFilter<"Supplier"> | string | null
    Contact_Email?: StringNullableFilter<"Supplier"> | string | null
    Notes?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    Supplied_Products?: InventoryListRelationFilter
    Supplied_Stock_Batches?: StockBatchListRelationFilter
    Supplied_Purchases?: InventoryPurchaseListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    Supplier_Id?: SortOrder
    Supplier_Name?: SortOrder
    Contact_Name?: SortOrderInput | SortOrder
    Contact_Phone_Number?: SortOrderInput | SortOrder
    Contact_Email?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Supplied_Products?: InventoryOrderByRelationAggregateInput
    Supplied_Stock_Batches?: StockBatchOrderByRelationAggregateInput
    Supplied_Purchases?: InventoryPurchaseOrderByRelationAggregateInput
    _relevance?: SupplierOrderByRelevanceInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    Supplier_Id?: number
    Contact_Email?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    Supplier_Name?: StringFilter<"Supplier"> | string
    Contact_Name?: StringNullableFilter<"Supplier"> | string | null
    Contact_Phone_Number?: StringNullableFilter<"Supplier"> | string | null
    Notes?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    Supplied_Products?: InventoryListRelationFilter
    Supplied_Stock_Batches?: StockBatchListRelationFilter
    Supplied_Purchases?: InventoryPurchaseListRelationFilter
  }, "Supplier_Id" | "Contact_Email">

  export type SupplierOrderByWithAggregationInput = {
    Supplier_Id?: SortOrder
    Supplier_Name?: SortOrder
    Contact_Name?: SortOrderInput | SortOrder
    Contact_Phone_Number?: SortOrderInput | SortOrder
    Contact_Email?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    Supplier_Id?: IntWithAggregatesFilter<"Supplier"> | number
    Supplier_Name?: StringWithAggregatesFilter<"Supplier"> | string
    Contact_Name?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    Contact_Phone_Number?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    Contact_Email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    Notes?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Supplier"> | Date | string | null
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    Employee_Id?: IntFilter<"Employee"> | number
    First_Name?: StringFilter<"Employee"> | string
    Last_Name?: StringFilter<"Employee"> | string
    Gender?: StringFilter<"Employee"> | string
    Email?: StringFilter<"Employee"> | string
    Password?: StringFilter<"Employee"> | string
    Profile_Image?: StringNullableFilter<"Employee"> | string | null
    Phone_Number?: StringFilter<"Employee"> | string
    Job_Position?: StringFilter<"Employee"> | string
    Work_Shift?: StringFilter<"Employee"> | string
    Education_Details?: StringFilter<"Employee"> | string
    Work_Experience?: StringFilter<"Employee"> | string
    Monthly_Salary?: FloatFilter<"Employee"> | number
    Address?: JsonFilter<"Employee">
    About_Employee?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    Inventory_Packages?: InventoryPurchaseListRelationFilter
    Withdrawal_Logs?: WithdrawalLogListRelationFilter
    Work_Logs?: WorkLogListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    Employee_Id?: SortOrder
    First_Name?: SortOrder
    Last_Name?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Profile_Image?: SortOrderInput | SortOrder
    Phone_Number?: SortOrder
    Job_Position?: SortOrder
    Work_Shift?: SortOrder
    Education_Details?: SortOrder
    Work_Experience?: SortOrder
    Monthly_Salary?: SortOrder
    Address?: SortOrder
    About_Employee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Inventory_Packages?: InventoryPurchaseOrderByRelationAggregateInput
    Withdrawal_Logs?: WithdrawalLogOrderByRelationAggregateInput
    Work_Logs?: WorkLogOrderByRelationAggregateInput
    _relevance?: EmployeeOrderByRelevanceInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    Employee_Id?: number
    Email?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    First_Name?: StringFilter<"Employee"> | string
    Last_Name?: StringFilter<"Employee"> | string
    Gender?: StringFilter<"Employee"> | string
    Password?: StringFilter<"Employee"> | string
    Profile_Image?: StringNullableFilter<"Employee"> | string | null
    Phone_Number?: StringFilter<"Employee"> | string
    Job_Position?: StringFilter<"Employee"> | string
    Work_Shift?: StringFilter<"Employee"> | string
    Education_Details?: StringFilter<"Employee"> | string
    Work_Experience?: StringFilter<"Employee"> | string
    Monthly_Salary?: FloatFilter<"Employee"> | number
    Address?: JsonFilter<"Employee">
    About_Employee?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    Inventory_Packages?: InventoryPurchaseListRelationFilter
    Withdrawal_Logs?: WithdrawalLogListRelationFilter
    Work_Logs?: WorkLogListRelationFilter
  }, "Employee_Id" | "Email">

  export type EmployeeOrderByWithAggregationInput = {
    Employee_Id?: SortOrder
    First_Name?: SortOrder
    Last_Name?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Profile_Image?: SortOrderInput | SortOrder
    Phone_Number?: SortOrder
    Job_Position?: SortOrder
    Work_Shift?: SortOrder
    Education_Details?: SortOrder
    Work_Experience?: SortOrder
    Monthly_Salary?: SortOrder
    Address?: SortOrder
    About_Employee?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    Employee_Id?: IntWithAggregatesFilter<"Employee"> | number
    First_Name?: StringWithAggregatesFilter<"Employee"> | string
    Last_Name?: StringWithAggregatesFilter<"Employee"> | string
    Gender?: StringWithAggregatesFilter<"Employee"> | string
    Email?: StringWithAggregatesFilter<"Employee"> | string
    Password?: StringWithAggregatesFilter<"Employee"> | string
    Profile_Image?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    Phone_Number?: StringWithAggregatesFilter<"Employee"> | string
    Job_Position?: StringWithAggregatesFilter<"Employee"> | string
    Work_Shift?: StringWithAggregatesFilter<"Employee"> | string
    Education_Details?: StringWithAggregatesFilter<"Employee"> | string
    Work_Experience?: StringWithAggregatesFilter<"Employee"> | string
    Monthly_Salary?: FloatWithAggregatesFilter<"Employee"> | number
    Address?: JsonWithAggregatesFilter<"Employee">
    About_Employee?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
  }

  export type WorkLogWhereInput = {
    AND?: WorkLogWhereInput | WorkLogWhereInput[]
    OR?: WorkLogWhereInput[]
    NOT?: WorkLogWhereInput | WorkLogWhereInput[]
    WorkLog_Id?: IntFilter<"WorkLog"> | number
    Employee_Id?: IntFilter<"WorkLog"> | number
    Login_Time?: DateTimeFilter<"WorkLog"> | Date | string
    Logout_Time?: DateTimeNullableFilter<"WorkLog"> | Date | string | null
    Employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type WorkLogOrderByWithRelationInput = {
    WorkLog_Id?: SortOrder
    Employee_Id?: SortOrder
    Login_Time?: SortOrder
    Logout_Time?: SortOrderInput | SortOrder
    Employee?: EmployeeOrderByWithRelationInput
  }

  export type WorkLogWhereUniqueInput = Prisma.AtLeast<{
    WorkLog_Id?: number
    AND?: WorkLogWhereInput | WorkLogWhereInput[]
    OR?: WorkLogWhereInput[]
    NOT?: WorkLogWhereInput | WorkLogWhereInput[]
    Employee_Id?: IntFilter<"WorkLog"> | number
    Login_Time?: DateTimeFilter<"WorkLog"> | Date | string
    Logout_Time?: DateTimeNullableFilter<"WorkLog"> | Date | string | null
    Employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "WorkLog_Id">

  export type WorkLogOrderByWithAggregationInput = {
    WorkLog_Id?: SortOrder
    Employee_Id?: SortOrder
    Login_Time?: SortOrder
    Logout_Time?: SortOrderInput | SortOrder
    _count?: WorkLogCountOrderByAggregateInput
    _avg?: WorkLogAvgOrderByAggregateInput
    _max?: WorkLogMaxOrderByAggregateInput
    _min?: WorkLogMinOrderByAggregateInput
    _sum?: WorkLogSumOrderByAggregateInput
  }

  export type WorkLogScalarWhereWithAggregatesInput = {
    AND?: WorkLogScalarWhereWithAggregatesInput | WorkLogScalarWhereWithAggregatesInput[]
    OR?: WorkLogScalarWhereWithAggregatesInput[]
    NOT?: WorkLogScalarWhereWithAggregatesInput | WorkLogScalarWhereWithAggregatesInput[]
    WorkLog_Id?: IntWithAggregatesFilter<"WorkLog"> | number
    Employee_Id?: IntWithAggregatesFilter<"WorkLog"> | number
    Login_Time?: DateTimeWithAggregatesFilter<"WorkLog"> | Date | string
    Logout_Time?: DateTimeNullableWithAggregatesFilter<"WorkLog"> | Date | string | null
  }

  export type InventoryCreateInput = {
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplier?: SupplierCreateNestedOneWithoutSupplied_ProductsInput
    Inventory_Purchases?: InventoryPurchaseCreateNestedManyWithoutInventoryInput
    Withdrawal_Logs?: WithdrawalLogCreateNestedManyWithoutInventoryInput
    Stock_Batches?: StockBatchCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    Inventory_Id?: number
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    Supplier_Id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Purchases?: InventoryPurchaseUncheckedCreateNestedManyWithoutInventoryInput
    Withdrawal_Logs?: WithdrawalLogUncheckedCreateNestedManyWithoutInventoryInput
    Stock_Batches?: StockBatchUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplier?: SupplierUpdateOneWithoutSupplied_ProductsNestedInput
    Inventory_Purchases?: InventoryPurchaseUpdateManyWithoutInventoryNestedInput
    Withdrawal_Logs?: WithdrawalLogUpdateManyWithoutInventoryNestedInput
    Stock_Batches?: StockBatchUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Purchases?: InventoryPurchaseUncheckedUpdateManyWithoutInventoryNestedInput
    Withdrawal_Logs?: WithdrawalLogUncheckedUpdateManyWithoutInventoryNestedInput
    Stock_Batches?: StockBatchUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    Inventory_Id?: number
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    Supplier_Id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type InventoryUpdateManyMutationInput = {
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryUncheckedUpdateManyInput = {
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalLogCreateInput = {
    Withdrawal_Reason?: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn?: Date | string
    updatedAt?: Date | string | null
    Inventory: InventoryCreateNestedOneWithoutWithdrawal_LogsInput
    Employee?: EmployeeCreateNestedOneWithoutWithdrawal_LogsInput
  }

  export type WithdrawalLogUncheckedCreateInput = {
    WithdrawalLog_Id?: number
    Inventory_Id: number
    Employee_Id?: number | null
    Withdrawal_Reason?: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalLogUpdateInput = {
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory?: InventoryUpdateOneRequiredWithoutWithdrawal_LogsNestedInput
    Employee?: EmployeeUpdateOneWithoutWithdrawal_LogsNestedInput
  }

  export type WithdrawalLogUncheckedUpdateInput = {
    WithdrawalLog_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalLogCreateManyInput = {
    WithdrawalLog_Id?: number
    Inventory_Id: number
    Employee_Id?: number | null
    Withdrawal_Reason?: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalLogUpdateManyMutationInput = {
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalLogUncheckedUpdateManyInput = {
    WithdrawalLog_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryPurchaseCreateInput = {
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory: InventoryCreateNestedOneWithoutInventory_PurchasesInput
    Supplier?: SupplierCreateNestedOneWithoutSupplied_PurchasesInput
    Employee?: EmployeeCreateNestedOneWithoutInventory_PackagesInput
  }

  export type InventoryPurchaseUncheckedCreateInput = {
    Purchase_Id?: number
    Inventory_Id: number
    Employee_Id?: number | null
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type InventoryPurchaseUpdateInput = {
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory?: InventoryUpdateOneRequiredWithoutInventory_PurchasesNestedInput
    Supplier?: SupplierUpdateOneWithoutSupplied_PurchasesNestedInput
    Employee?: EmployeeUpdateOneWithoutInventory_PackagesNestedInput
  }

  export type InventoryPurchaseUncheckedUpdateInput = {
    Purchase_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryPurchaseCreateManyInput = {
    Purchase_Id?: number
    Inventory_Id: number
    Employee_Id?: number | null
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type InventoryPurchaseUpdateManyMutationInput = {
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryPurchaseUncheckedUpdateManyInput = {
    Purchase_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockBatchCreateInput = {
    Batch_Number: string
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date?: Date | string | null
    Remaining_Quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory: InventoryCreateNestedOneWithoutStock_BatchesInput
    Supplier?: SupplierCreateNestedOneWithoutSupplied_Stock_BatchesInput
  }

  export type StockBatchUncheckedCreateInput = {
    StockBatch_Id?: number
    Batch_Number: string
    Inventory_Id: number
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date?: Date | string | null
    Remaining_Quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockBatchUpdateInput = {
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory?: InventoryUpdateOneRequiredWithoutStock_BatchesNestedInput
    Supplier?: SupplierUpdateOneWithoutSupplied_Stock_BatchesNestedInput
  }

  export type StockBatchUncheckedUpdateInput = {
    StockBatch_Id?: IntFieldUpdateOperationsInput | number
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockBatchCreateManyInput = {
    StockBatch_Id?: number
    Batch_Number: string
    Inventory_Id: number
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date?: Date | string | null
    Remaining_Quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockBatchUpdateManyMutationInput = {
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockBatchUncheckedUpdateManyInput = {
    StockBatch_Id?: IntFieldUpdateOperationsInput | number
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierCreateInput = {
    Supplier_Name: string
    Contact_Name?: string | null
    Contact_Phone_Number?: string | null
    Contact_Email?: string | null
    Notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplied_Products?: InventoryCreateNestedManyWithoutSupplierInput
    Supplied_Stock_Batches?: StockBatchCreateNestedManyWithoutSupplierInput
    Supplied_Purchases?: InventoryPurchaseCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    Supplier_Id?: number
    Supplier_Name: string
    Contact_Name?: string | null
    Contact_Phone_Number?: string | null
    Contact_Email?: string | null
    Notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplied_Products?: InventoryUncheckedCreateNestedManyWithoutSupplierInput
    Supplied_Stock_Batches?: StockBatchUncheckedCreateNestedManyWithoutSupplierInput
    Supplied_Purchases?: InventoryPurchaseUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplied_Products?: InventoryUpdateManyWithoutSupplierNestedInput
    Supplied_Stock_Batches?: StockBatchUpdateManyWithoutSupplierNestedInput
    Supplied_Purchases?: InventoryPurchaseUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    Supplier_Id?: IntFieldUpdateOperationsInput | number
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplied_Products?: InventoryUncheckedUpdateManyWithoutSupplierNestedInput
    Supplied_Stock_Batches?: StockBatchUncheckedUpdateManyWithoutSupplierNestedInput
    Supplied_Purchases?: InventoryPurchaseUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    Supplier_Id?: number
    Supplier_Name: string
    Contact_Name?: string | null
    Contact_Phone_Number?: string | null
    Contact_Email?: string | null
    Notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SupplierUpdateManyMutationInput = {
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    Supplier_Id?: IntFieldUpdateOperationsInput | number
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateInput = {
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image?: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonNullValueInput | InputJsonValue
    About_Employee?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Packages?: InventoryPurchaseCreateNestedManyWithoutEmployeeInput
    Withdrawal_Logs?: WithdrawalLogCreateNestedManyWithoutEmployeeInput
    Work_Logs?: WorkLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    Employee_Id?: number
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image?: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonNullValueInput | InputJsonValue
    About_Employee?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Packages?: InventoryPurchaseUncheckedCreateNestedManyWithoutEmployeeInput
    Withdrawal_Logs?: WithdrawalLogUncheckedCreateNestedManyWithoutEmployeeInput
    Work_Logs?: WorkLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Packages?: InventoryPurchaseUpdateManyWithoutEmployeeNestedInput
    Withdrawal_Logs?: WithdrawalLogUpdateManyWithoutEmployeeNestedInput
    Work_Logs?: WorkLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    Employee_Id?: IntFieldUpdateOperationsInput | number
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Packages?: InventoryPurchaseUncheckedUpdateManyWithoutEmployeeNestedInput
    Withdrawal_Logs?: WithdrawalLogUncheckedUpdateManyWithoutEmployeeNestedInput
    Work_Logs?: WorkLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    Employee_Id?: number
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image?: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonNullValueInput | InputJsonValue
    About_Employee?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type EmployeeUpdateManyMutationInput = {
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeUncheckedUpdateManyInput = {
    Employee_Id?: IntFieldUpdateOperationsInput | number
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkLogCreateInput = {
    Login_Time?: Date | string
    Logout_Time?: Date | string | null
    Employee: EmployeeCreateNestedOneWithoutWork_LogsInput
  }

  export type WorkLogUncheckedCreateInput = {
    WorkLog_Id?: number
    Employee_Id: number
    Login_Time?: Date | string
    Logout_Time?: Date | string | null
  }

  export type WorkLogUpdateInput = {
    Login_Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Logout_Time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateOneRequiredWithoutWork_LogsNestedInput
  }

  export type WorkLogUncheckedUpdateInput = {
    WorkLog_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: IntFieldUpdateOperationsInput | number
    Login_Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Logout_Time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkLogCreateManyInput = {
    WorkLog_Id?: number
    Employee_Id: number
    Login_Time?: Date | string
    Logout_Time?: Date | string | null
  }

  export type WorkLogUpdateManyMutationInput = {
    Login_Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Logout_Time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkLogUncheckedUpdateManyInput = {
    WorkLog_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: IntFieldUpdateOperationsInput | number
    Login_Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Logout_Time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type InventoryPurchaseListRelationFilter = {
    every?: InventoryPurchaseWhereInput
    some?: InventoryPurchaseWhereInput
    none?: InventoryPurchaseWhereInput
  }

  export type WithdrawalLogListRelationFilter = {
    every?: WithdrawalLogWhereInput
    some?: WithdrawalLogWhereInput
    none?: WithdrawalLogWhereInput
  }

  export type StockBatchListRelationFilter = {
    every?: StockBatchWhereInput
    some?: StockBatchWhereInput
    none?: StockBatchWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InventoryPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WithdrawalLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelevanceInput = {
    fields: InventoryOrderByRelevanceFieldEnum | InventoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InventoryCountOrderByAggregateInput = {
    Inventory_Id?: SortOrder
    Product_Name?: SortOrder
    Product_Category?: SortOrder
    Product_Description?: SortOrder
    Is_Discontinued?: SortOrder
    Stock_Quantity?: SortOrder
    Reorder_Threshold?: SortOrder
    Total_Value?: SortOrder
    Unit_Of_Measurement?: SortOrder
    Unit_Price?: SortOrder
    Stock_Status?: SortOrder
    Storage_Location?: SortOrder
    Expiry_Date?: SortOrder
    Initial_Stock_Quantity?: SortOrder
    Supplier_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    Inventory_Id?: SortOrder
    Stock_Quantity?: SortOrder
    Reorder_Threshold?: SortOrder
    Total_Value?: SortOrder
    Unit_Price?: SortOrder
    Initial_Stock_Quantity?: SortOrder
    Supplier_Id?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    Inventory_Id?: SortOrder
    Product_Name?: SortOrder
    Product_Category?: SortOrder
    Product_Description?: SortOrder
    Is_Discontinued?: SortOrder
    Stock_Quantity?: SortOrder
    Reorder_Threshold?: SortOrder
    Total_Value?: SortOrder
    Unit_Of_Measurement?: SortOrder
    Unit_Price?: SortOrder
    Stock_Status?: SortOrder
    Storage_Location?: SortOrder
    Expiry_Date?: SortOrder
    Initial_Stock_Quantity?: SortOrder
    Supplier_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    Inventory_Id?: SortOrder
    Product_Name?: SortOrder
    Product_Category?: SortOrder
    Product_Description?: SortOrder
    Is_Discontinued?: SortOrder
    Stock_Quantity?: SortOrder
    Reorder_Threshold?: SortOrder
    Total_Value?: SortOrder
    Unit_Of_Measurement?: SortOrder
    Unit_Price?: SortOrder
    Stock_Status?: SortOrder
    Storage_Location?: SortOrder
    Expiry_Date?: SortOrder
    Initial_Stock_Quantity?: SortOrder
    Supplier_Id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    Inventory_Id?: SortOrder
    Stock_Quantity?: SortOrder
    Reorder_Threshold?: SortOrder
    Total_Value?: SortOrder
    Unit_Price?: SortOrder
    Initial_Stock_Quantity?: SortOrder
    Supplier_Id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type InventoryScalarRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type WithdrawalLogOrderByRelevanceInput = {
    fields: WithdrawalLogOrderByRelevanceFieldEnum | WithdrawalLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WithdrawalLogCountOrderByAggregateInput = {
    WithdrawalLog_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Withdrawal_Reason?: SortOrder
    Quantity_Withdrawn?: SortOrder
    Date_Withdrawn?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawalLogAvgOrderByAggregateInput = {
    WithdrawalLog_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Quantity_Withdrawn?: SortOrder
  }

  export type WithdrawalLogMaxOrderByAggregateInput = {
    WithdrawalLog_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Withdrawal_Reason?: SortOrder
    Quantity_Withdrawn?: SortOrder
    Date_Withdrawn?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawalLogMinOrderByAggregateInput = {
    WithdrawalLog_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Withdrawal_Reason?: SortOrder
    Quantity_Withdrawn?: SortOrder
    Date_Withdrawn?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawalLogSumOrderByAggregateInput = {
    WithdrawalLog_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Quantity_Withdrawn?: SortOrder
  }

  export type InventoryPurchaseCountOrderByAggregateInput = {
    Purchase_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Supplier_Id?: SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Total_Cost?: SortOrder
    Unit_Price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryPurchaseAvgOrderByAggregateInput = {
    Purchase_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Supplier_Id?: SortOrder
    Quantity_Purchased?: SortOrder
    Total_Cost?: SortOrder
    Unit_Price?: SortOrder
  }

  export type InventoryPurchaseMaxOrderByAggregateInput = {
    Purchase_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Supplier_Id?: SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Total_Cost?: SortOrder
    Unit_Price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryPurchaseMinOrderByAggregateInput = {
    Purchase_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Supplier_Id?: SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Total_Cost?: SortOrder
    Unit_Price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryPurchaseSumOrderByAggregateInput = {
    Purchase_Id?: SortOrder
    Inventory_Id?: SortOrder
    Employee_Id?: SortOrder
    Supplier_Id?: SortOrder
    Quantity_Purchased?: SortOrder
    Total_Cost?: SortOrder
    Unit_Price?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StockBatchOrderByRelevanceInput = {
    fields: StockBatchOrderByRelevanceFieldEnum | StockBatchOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StockBatchCountOrderByAggregateInput = {
    StockBatch_Id?: SortOrder
    Batch_Number?: SortOrder
    Inventory_Id?: SortOrder
    Supplier_Id?: SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Unit_Price?: SortOrder
    Expiry_Date?: SortOrder
    Remaining_Quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockBatchAvgOrderByAggregateInput = {
    StockBatch_Id?: SortOrder
    Inventory_Id?: SortOrder
    Supplier_Id?: SortOrder
    Quantity_Purchased?: SortOrder
    Unit_Price?: SortOrder
    Remaining_Quantity?: SortOrder
  }

  export type StockBatchMaxOrderByAggregateInput = {
    StockBatch_Id?: SortOrder
    Batch_Number?: SortOrder
    Inventory_Id?: SortOrder
    Supplier_Id?: SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Unit_Price?: SortOrder
    Expiry_Date?: SortOrder
    Remaining_Quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockBatchMinOrderByAggregateInput = {
    StockBatch_Id?: SortOrder
    Batch_Number?: SortOrder
    Inventory_Id?: SortOrder
    Supplier_Id?: SortOrder
    Purchase_Date?: SortOrder
    Quantity_Purchased?: SortOrder
    Unit_Price?: SortOrder
    Expiry_Date?: SortOrder
    Remaining_Quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockBatchSumOrderByAggregateInput = {
    StockBatch_Id?: SortOrder
    Inventory_Id?: SortOrder
    Supplier_Id?: SortOrder
    Quantity_Purchased?: SortOrder
    Unit_Price?: SortOrder
    Remaining_Quantity?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelevanceInput = {
    fields: SupplierOrderByRelevanceFieldEnum | SupplierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SupplierCountOrderByAggregateInput = {
    Supplier_Id?: SortOrder
    Supplier_Name?: SortOrder
    Contact_Name?: SortOrder
    Contact_Phone_Number?: SortOrder
    Contact_Email?: SortOrder
    Notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    Supplier_Id?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    Supplier_Id?: SortOrder
    Supplier_Name?: SortOrder
    Contact_Name?: SortOrder
    Contact_Phone_Number?: SortOrder
    Contact_Email?: SortOrder
    Notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    Supplier_Id?: SortOrder
    Supplier_Name?: SortOrder
    Contact_Name?: SortOrder
    Contact_Phone_Number?: SortOrder
    Contact_Email?: SortOrder
    Notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    Supplier_Id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WorkLogListRelationFilter = {
    every?: WorkLogWhereInput
    some?: WorkLogWhereInput
    none?: WorkLogWhereInput
  }

  export type WorkLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelevanceInput = {
    fields: EmployeeOrderByRelevanceFieldEnum | EmployeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmployeeCountOrderByAggregateInput = {
    Employee_Id?: SortOrder
    First_Name?: SortOrder
    Last_Name?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Profile_Image?: SortOrder
    Phone_Number?: SortOrder
    Job_Position?: SortOrder
    Work_Shift?: SortOrder
    Education_Details?: SortOrder
    Work_Experience?: SortOrder
    Monthly_Salary?: SortOrder
    Address?: SortOrder
    About_Employee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    Employee_Id?: SortOrder
    Monthly_Salary?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    Employee_Id?: SortOrder
    First_Name?: SortOrder
    Last_Name?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Profile_Image?: SortOrder
    Phone_Number?: SortOrder
    Job_Position?: SortOrder
    Work_Shift?: SortOrder
    Education_Details?: SortOrder
    Work_Experience?: SortOrder
    Monthly_Salary?: SortOrder
    About_Employee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    Employee_Id?: SortOrder
    First_Name?: SortOrder
    Last_Name?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Profile_Image?: SortOrder
    Phone_Number?: SortOrder
    Job_Position?: SortOrder
    Work_Shift?: SortOrder
    Education_Details?: SortOrder
    Work_Experience?: SortOrder
    Monthly_Salary?: SortOrder
    About_Employee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    Employee_Id?: SortOrder
    Monthly_Salary?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type WorkLogCountOrderByAggregateInput = {
    WorkLog_Id?: SortOrder
    Employee_Id?: SortOrder
    Login_Time?: SortOrder
    Logout_Time?: SortOrder
  }

  export type WorkLogAvgOrderByAggregateInput = {
    WorkLog_Id?: SortOrder
    Employee_Id?: SortOrder
  }

  export type WorkLogMaxOrderByAggregateInput = {
    WorkLog_Id?: SortOrder
    Employee_Id?: SortOrder
    Login_Time?: SortOrder
    Logout_Time?: SortOrder
  }

  export type WorkLogMinOrderByAggregateInput = {
    WorkLog_Id?: SortOrder
    Employee_Id?: SortOrder
    Login_Time?: SortOrder
    Logout_Time?: SortOrder
  }

  export type WorkLogSumOrderByAggregateInput = {
    WorkLog_Id?: SortOrder
    Employee_Id?: SortOrder
  }

  export type SupplierCreateNestedOneWithoutSupplied_ProductsInput = {
    create?: XOR<SupplierCreateWithoutSupplied_ProductsInput, SupplierUncheckedCreateWithoutSupplied_ProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSupplied_ProductsInput
    connect?: SupplierWhereUniqueInput
  }

  export type InventoryPurchaseCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryPurchaseCreateWithoutInventoryInput, InventoryPurchaseUncheckedCreateWithoutInventoryInput> | InventoryPurchaseCreateWithoutInventoryInput[] | InventoryPurchaseUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutInventoryInput | InventoryPurchaseCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryPurchaseCreateManyInventoryInputEnvelope
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
  }

  export type WithdrawalLogCreateNestedManyWithoutInventoryInput = {
    create?: XOR<WithdrawalLogCreateWithoutInventoryInput, WithdrawalLogUncheckedCreateWithoutInventoryInput> | WithdrawalLogCreateWithoutInventoryInput[] | WithdrawalLogUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: WithdrawalLogCreateOrConnectWithoutInventoryInput | WithdrawalLogCreateOrConnectWithoutInventoryInput[]
    createMany?: WithdrawalLogCreateManyInventoryInputEnvelope
    connect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
  }

  export type StockBatchCreateNestedManyWithoutInventoryInput = {
    create?: XOR<StockBatchCreateWithoutInventoryInput, StockBatchUncheckedCreateWithoutInventoryInput> | StockBatchCreateWithoutInventoryInput[] | StockBatchUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: StockBatchCreateOrConnectWithoutInventoryInput | StockBatchCreateOrConnectWithoutInventoryInput[]
    createMany?: StockBatchCreateManyInventoryInputEnvelope
    connect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
  }

  export type InventoryPurchaseUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryPurchaseCreateWithoutInventoryInput, InventoryPurchaseUncheckedCreateWithoutInventoryInput> | InventoryPurchaseCreateWithoutInventoryInput[] | InventoryPurchaseUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutInventoryInput | InventoryPurchaseCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryPurchaseCreateManyInventoryInputEnvelope
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
  }

  export type WithdrawalLogUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<WithdrawalLogCreateWithoutInventoryInput, WithdrawalLogUncheckedCreateWithoutInventoryInput> | WithdrawalLogCreateWithoutInventoryInput[] | WithdrawalLogUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: WithdrawalLogCreateOrConnectWithoutInventoryInput | WithdrawalLogCreateOrConnectWithoutInventoryInput[]
    createMany?: WithdrawalLogCreateManyInventoryInputEnvelope
    connect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
  }

  export type StockBatchUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<StockBatchCreateWithoutInventoryInput, StockBatchUncheckedCreateWithoutInventoryInput> | StockBatchCreateWithoutInventoryInput[] | StockBatchUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: StockBatchCreateOrConnectWithoutInventoryInput | StockBatchCreateOrConnectWithoutInventoryInput[]
    createMany?: StockBatchCreateManyInventoryInputEnvelope
    connect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SupplierUpdateOneWithoutSupplied_ProductsNestedInput = {
    create?: XOR<SupplierCreateWithoutSupplied_ProductsInput, SupplierUncheckedCreateWithoutSupplied_ProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSupplied_ProductsInput
    upsert?: SupplierUpsertWithoutSupplied_ProductsInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutSupplied_ProductsInput, SupplierUpdateWithoutSupplied_ProductsInput>, SupplierUncheckedUpdateWithoutSupplied_ProductsInput>
  }

  export type InventoryPurchaseUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryPurchaseCreateWithoutInventoryInput, InventoryPurchaseUncheckedCreateWithoutInventoryInput> | InventoryPurchaseCreateWithoutInventoryInput[] | InventoryPurchaseUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutInventoryInput | InventoryPurchaseCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryPurchaseUpsertWithWhereUniqueWithoutInventoryInput | InventoryPurchaseUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryPurchaseCreateManyInventoryInputEnvelope
    set?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    disconnect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    delete?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    update?: InventoryPurchaseUpdateWithWhereUniqueWithoutInventoryInput | InventoryPurchaseUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryPurchaseUpdateManyWithWhereWithoutInventoryInput | InventoryPurchaseUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryPurchaseScalarWhereInput | InventoryPurchaseScalarWhereInput[]
  }

  export type WithdrawalLogUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<WithdrawalLogCreateWithoutInventoryInput, WithdrawalLogUncheckedCreateWithoutInventoryInput> | WithdrawalLogCreateWithoutInventoryInput[] | WithdrawalLogUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: WithdrawalLogCreateOrConnectWithoutInventoryInput | WithdrawalLogCreateOrConnectWithoutInventoryInput[]
    upsert?: WithdrawalLogUpsertWithWhereUniqueWithoutInventoryInput | WithdrawalLogUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: WithdrawalLogCreateManyInventoryInputEnvelope
    set?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    disconnect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    delete?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    connect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    update?: WithdrawalLogUpdateWithWhereUniqueWithoutInventoryInput | WithdrawalLogUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: WithdrawalLogUpdateManyWithWhereWithoutInventoryInput | WithdrawalLogUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: WithdrawalLogScalarWhereInput | WithdrawalLogScalarWhereInput[]
  }

  export type StockBatchUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<StockBatchCreateWithoutInventoryInput, StockBatchUncheckedCreateWithoutInventoryInput> | StockBatchCreateWithoutInventoryInput[] | StockBatchUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: StockBatchCreateOrConnectWithoutInventoryInput | StockBatchCreateOrConnectWithoutInventoryInput[]
    upsert?: StockBatchUpsertWithWhereUniqueWithoutInventoryInput | StockBatchUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: StockBatchCreateManyInventoryInputEnvelope
    set?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    disconnect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    delete?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    connect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    update?: StockBatchUpdateWithWhereUniqueWithoutInventoryInput | StockBatchUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: StockBatchUpdateManyWithWhereWithoutInventoryInput | StockBatchUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: StockBatchScalarWhereInput | StockBatchScalarWhereInput[]
  }

  export type InventoryPurchaseUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryPurchaseCreateWithoutInventoryInput, InventoryPurchaseUncheckedCreateWithoutInventoryInput> | InventoryPurchaseCreateWithoutInventoryInput[] | InventoryPurchaseUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutInventoryInput | InventoryPurchaseCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryPurchaseUpsertWithWhereUniqueWithoutInventoryInput | InventoryPurchaseUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryPurchaseCreateManyInventoryInputEnvelope
    set?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    disconnect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    delete?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    update?: InventoryPurchaseUpdateWithWhereUniqueWithoutInventoryInput | InventoryPurchaseUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryPurchaseUpdateManyWithWhereWithoutInventoryInput | InventoryPurchaseUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryPurchaseScalarWhereInput | InventoryPurchaseScalarWhereInput[]
  }

  export type WithdrawalLogUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<WithdrawalLogCreateWithoutInventoryInput, WithdrawalLogUncheckedCreateWithoutInventoryInput> | WithdrawalLogCreateWithoutInventoryInput[] | WithdrawalLogUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: WithdrawalLogCreateOrConnectWithoutInventoryInput | WithdrawalLogCreateOrConnectWithoutInventoryInput[]
    upsert?: WithdrawalLogUpsertWithWhereUniqueWithoutInventoryInput | WithdrawalLogUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: WithdrawalLogCreateManyInventoryInputEnvelope
    set?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    disconnect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    delete?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    connect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    update?: WithdrawalLogUpdateWithWhereUniqueWithoutInventoryInput | WithdrawalLogUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: WithdrawalLogUpdateManyWithWhereWithoutInventoryInput | WithdrawalLogUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: WithdrawalLogScalarWhereInput | WithdrawalLogScalarWhereInput[]
  }

  export type StockBatchUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<StockBatchCreateWithoutInventoryInput, StockBatchUncheckedCreateWithoutInventoryInput> | StockBatchCreateWithoutInventoryInput[] | StockBatchUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: StockBatchCreateOrConnectWithoutInventoryInput | StockBatchCreateOrConnectWithoutInventoryInput[]
    upsert?: StockBatchUpsertWithWhereUniqueWithoutInventoryInput | StockBatchUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: StockBatchCreateManyInventoryInputEnvelope
    set?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    disconnect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    delete?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    connect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    update?: StockBatchUpdateWithWhereUniqueWithoutInventoryInput | StockBatchUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: StockBatchUpdateManyWithWhereWithoutInventoryInput | StockBatchUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: StockBatchScalarWhereInput | StockBatchScalarWhereInput[]
  }

  export type InventoryCreateNestedOneWithoutWithdrawal_LogsInput = {
    create?: XOR<InventoryCreateWithoutWithdrawal_LogsInput, InventoryUncheckedCreateWithoutWithdrawal_LogsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutWithdrawal_LogsInput
    connect?: InventoryWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutWithdrawal_LogsInput = {
    create?: XOR<EmployeeCreateWithoutWithdrawal_LogsInput, EmployeeUncheckedCreateWithoutWithdrawal_LogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWithdrawal_LogsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type InventoryUpdateOneRequiredWithoutWithdrawal_LogsNestedInput = {
    create?: XOR<InventoryCreateWithoutWithdrawal_LogsInput, InventoryUncheckedCreateWithoutWithdrawal_LogsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutWithdrawal_LogsInput
    upsert?: InventoryUpsertWithoutWithdrawal_LogsInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutWithdrawal_LogsInput, InventoryUpdateWithoutWithdrawal_LogsInput>, InventoryUncheckedUpdateWithoutWithdrawal_LogsInput>
  }

  export type EmployeeUpdateOneWithoutWithdrawal_LogsNestedInput = {
    create?: XOR<EmployeeCreateWithoutWithdrawal_LogsInput, EmployeeUncheckedCreateWithoutWithdrawal_LogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWithdrawal_LogsInput
    upsert?: EmployeeUpsertWithoutWithdrawal_LogsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWithdrawal_LogsInput, EmployeeUpdateWithoutWithdrawal_LogsInput>, EmployeeUncheckedUpdateWithoutWithdrawal_LogsInput>
  }

  export type InventoryCreateNestedOneWithoutInventory_PurchasesInput = {
    create?: XOR<InventoryCreateWithoutInventory_PurchasesInput, InventoryUncheckedCreateWithoutInventory_PurchasesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventory_PurchasesInput
    connect?: InventoryWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutSupplied_PurchasesInput = {
    create?: XOR<SupplierCreateWithoutSupplied_PurchasesInput, SupplierUncheckedCreateWithoutSupplied_PurchasesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSupplied_PurchasesInput
    connect?: SupplierWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutInventory_PackagesInput = {
    create?: XOR<EmployeeCreateWithoutInventory_PackagesInput, EmployeeUncheckedCreateWithoutInventory_PackagesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutInventory_PackagesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type InventoryUpdateOneRequiredWithoutInventory_PurchasesNestedInput = {
    create?: XOR<InventoryCreateWithoutInventory_PurchasesInput, InventoryUncheckedCreateWithoutInventory_PurchasesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventory_PurchasesInput
    upsert?: InventoryUpsertWithoutInventory_PurchasesInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutInventory_PurchasesInput, InventoryUpdateWithoutInventory_PurchasesInput>, InventoryUncheckedUpdateWithoutInventory_PurchasesInput>
  }

  export type SupplierUpdateOneWithoutSupplied_PurchasesNestedInput = {
    create?: XOR<SupplierCreateWithoutSupplied_PurchasesInput, SupplierUncheckedCreateWithoutSupplied_PurchasesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSupplied_PurchasesInput
    upsert?: SupplierUpsertWithoutSupplied_PurchasesInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutSupplied_PurchasesInput, SupplierUpdateWithoutSupplied_PurchasesInput>, SupplierUncheckedUpdateWithoutSupplied_PurchasesInput>
  }

  export type EmployeeUpdateOneWithoutInventory_PackagesNestedInput = {
    create?: XOR<EmployeeCreateWithoutInventory_PackagesInput, EmployeeUncheckedCreateWithoutInventory_PackagesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutInventory_PackagesInput
    upsert?: EmployeeUpsertWithoutInventory_PackagesInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutInventory_PackagesInput, EmployeeUpdateWithoutInventory_PackagesInput>, EmployeeUncheckedUpdateWithoutInventory_PackagesInput>
  }

  export type InventoryCreateNestedOneWithoutStock_BatchesInput = {
    create?: XOR<InventoryCreateWithoutStock_BatchesInput, InventoryUncheckedCreateWithoutStock_BatchesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutStock_BatchesInput
    connect?: InventoryWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutSupplied_Stock_BatchesInput = {
    create?: XOR<SupplierCreateWithoutSupplied_Stock_BatchesInput, SupplierUncheckedCreateWithoutSupplied_Stock_BatchesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSupplied_Stock_BatchesInput
    connect?: SupplierWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InventoryUpdateOneRequiredWithoutStock_BatchesNestedInput = {
    create?: XOR<InventoryCreateWithoutStock_BatchesInput, InventoryUncheckedCreateWithoutStock_BatchesInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutStock_BatchesInput
    upsert?: InventoryUpsertWithoutStock_BatchesInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutStock_BatchesInput, InventoryUpdateWithoutStock_BatchesInput>, InventoryUncheckedUpdateWithoutStock_BatchesInput>
  }

  export type SupplierUpdateOneWithoutSupplied_Stock_BatchesNestedInput = {
    create?: XOR<SupplierCreateWithoutSupplied_Stock_BatchesInput, SupplierUncheckedCreateWithoutSupplied_Stock_BatchesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSupplied_Stock_BatchesInput
    upsert?: SupplierUpsertWithoutSupplied_Stock_BatchesInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutSupplied_Stock_BatchesInput, SupplierUpdateWithoutSupplied_Stock_BatchesInput>, SupplierUncheckedUpdateWithoutSupplied_Stock_BatchesInput>
  }

  export type InventoryCreateNestedManyWithoutSupplierInput = {
    create?: XOR<InventoryCreateWithoutSupplierInput, InventoryUncheckedCreateWithoutSupplierInput> | InventoryCreateWithoutSupplierInput[] | InventoryUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutSupplierInput | InventoryCreateOrConnectWithoutSupplierInput[]
    createMany?: InventoryCreateManySupplierInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type StockBatchCreateNestedManyWithoutSupplierInput = {
    create?: XOR<StockBatchCreateWithoutSupplierInput, StockBatchUncheckedCreateWithoutSupplierInput> | StockBatchCreateWithoutSupplierInput[] | StockBatchUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: StockBatchCreateOrConnectWithoutSupplierInput | StockBatchCreateOrConnectWithoutSupplierInput[]
    createMany?: StockBatchCreateManySupplierInputEnvelope
    connect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
  }

  export type InventoryPurchaseCreateNestedManyWithoutSupplierInput = {
    create?: XOR<InventoryPurchaseCreateWithoutSupplierInput, InventoryPurchaseUncheckedCreateWithoutSupplierInput> | InventoryPurchaseCreateWithoutSupplierInput[] | InventoryPurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutSupplierInput | InventoryPurchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: InventoryPurchaseCreateManySupplierInputEnvelope
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<InventoryCreateWithoutSupplierInput, InventoryUncheckedCreateWithoutSupplierInput> | InventoryCreateWithoutSupplierInput[] | InventoryUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutSupplierInput | InventoryCreateOrConnectWithoutSupplierInput[]
    createMany?: InventoryCreateManySupplierInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type StockBatchUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<StockBatchCreateWithoutSupplierInput, StockBatchUncheckedCreateWithoutSupplierInput> | StockBatchCreateWithoutSupplierInput[] | StockBatchUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: StockBatchCreateOrConnectWithoutSupplierInput | StockBatchCreateOrConnectWithoutSupplierInput[]
    createMany?: StockBatchCreateManySupplierInputEnvelope
    connect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
  }

  export type InventoryPurchaseUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<InventoryPurchaseCreateWithoutSupplierInput, InventoryPurchaseUncheckedCreateWithoutSupplierInput> | InventoryPurchaseCreateWithoutSupplierInput[] | InventoryPurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutSupplierInput | InventoryPurchaseCreateOrConnectWithoutSupplierInput[]
    createMany?: InventoryPurchaseCreateManySupplierInputEnvelope
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
  }

  export type InventoryUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<InventoryCreateWithoutSupplierInput, InventoryUncheckedCreateWithoutSupplierInput> | InventoryCreateWithoutSupplierInput[] | InventoryUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutSupplierInput | InventoryCreateOrConnectWithoutSupplierInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutSupplierInput | InventoryUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: InventoryCreateManySupplierInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutSupplierInput | InventoryUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutSupplierInput | InventoryUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type StockBatchUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<StockBatchCreateWithoutSupplierInput, StockBatchUncheckedCreateWithoutSupplierInput> | StockBatchCreateWithoutSupplierInput[] | StockBatchUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: StockBatchCreateOrConnectWithoutSupplierInput | StockBatchCreateOrConnectWithoutSupplierInput[]
    upsert?: StockBatchUpsertWithWhereUniqueWithoutSupplierInput | StockBatchUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: StockBatchCreateManySupplierInputEnvelope
    set?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    disconnect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    delete?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    connect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    update?: StockBatchUpdateWithWhereUniqueWithoutSupplierInput | StockBatchUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: StockBatchUpdateManyWithWhereWithoutSupplierInput | StockBatchUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: StockBatchScalarWhereInput | StockBatchScalarWhereInput[]
  }

  export type InventoryPurchaseUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<InventoryPurchaseCreateWithoutSupplierInput, InventoryPurchaseUncheckedCreateWithoutSupplierInput> | InventoryPurchaseCreateWithoutSupplierInput[] | InventoryPurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutSupplierInput | InventoryPurchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: InventoryPurchaseUpsertWithWhereUniqueWithoutSupplierInput | InventoryPurchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: InventoryPurchaseCreateManySupplierInputEnvelope
    set?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    disconnect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    delete?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    update?: InventoryPurchaseUpdateWithWhereUniqueWithoutSupplierInput | InventoryPurchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: InventoryPurchaseUpdateManyWithWhereWithoutSupplierInput | InventoryPurchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: InventoryPurchaseScalarWhereInput | InventoryPurchaseScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<InventoryCreateWithoutSupplierInput, InventoryUncheckedCreateWithoutSupplierInput> | InventoryCreateWithoutSupplierInput[] | InventoryUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutSupplierInput | InventoryCreateOrConnectWithoutSupplierInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutSupplierInput | InventoryUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: InventoryCreateManySupplierInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutSupplierInput | InventoryUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutSupplierInput | InventoryUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type StockBatchUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<StockBatchCreateWithoutSupplierInput, StockBatchUncheckedCreateWithoutSupplierInput> | StockBatchCreateWithoutSupplierInput[] | StockBatchUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: StockBatchCreateOrConnectWithoutSupplierInput | StockBatchCreateOrConnectWithoutSupplierInput[]
    upsert?: StockBatchUpsertWithWhereUniqueWithoutSupplierInput | StockBatchUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: StockBatchCreateManySupplierInputEnvelope
    set?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    disconnect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    delete?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    connect?: StockBatchWhereUniqueInput | StockBatchWhereUniqueInput[]
    update?: StockBatchUpdateWithWhereUniqueWithoutSupplierInput | StockBatchUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: StockBatchUpdateManyWithWhereWithoutSupplierInput | StockBatchUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: StockBatchScalarWhereInput | StockBatchScalarWhereInput[]
  }

  export type InventoryPurchaseUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<InventoryPurchaseCreateWithoutSupplierInput, InventoryPurchaseUncheckedCreateWithoutSupplierInput> | InventoryPurchaseCreateWithoutSupplierInput[] | InventoryPurchaseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutSupplierInput | InventoryPurchaseCreateOrConnectWithoutSupplierInput[]
    upsert?: InventoryPurchaseUpsertWithWhereUniqueWithoutSupplierInput | InventoryPurchaseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: InventoryPurchaseCreateManySupplierInputEnvelope
    set?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    disconnect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    delete?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    update?: InventoryPurchaseUpdateWithWhereUniqueWithoutSupplierInput | InventoryPurchaseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: InventoryPurchaseUpdateManyWithWhereWithoutSupplierInput | InventoryPurchaseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: InventoryPurchaseScalarWhereInput | InventoryPurchaseScalarWhereInput[]
  }

  export type InventoryPurchaseCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<InventoryPurchaseCreateWithoutEmployeeInput, InventoryPurchaseUncheckedCreateWithoutEmployeeInput> | InventoryPurchaseCreateWithoutEmployeeInput[] | InventoryPurchaseUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutEmployeeInput | InventoryPurchaseCreateOrConnectWithoutEmployeeInput[]
    createMany?: InventoryPurchaseCreateManyEmployeeInputEnvelope
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
  }

  export type WithdrawalLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WithdrawalLogCreateWithoutEmployeeInput, WithdrawalLogUncheckedCreateWithoutEmployeeInput> | WithdrawalLogCreateWithoutEmployeeInput[] | WithdrawalLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WithdrawalLogCreateOrConnectWithoutEmployeeInput | WithdrawalLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: WithdrawalLogCreateManyEmployeeInputEnvelope
    connect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
  }

  export type WorkLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WorkLogCreateWithoutEmployeeInput, WorkLogUncheckedCreateWithoutEmployeeInput> | WorkLogCreateWithoutEmployeeInput[] | WorkLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkLogCreateOrConnectWithoutEmployeeInput | WorkLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: WorkLogCreateManyEmployeeInputEnvelope
    connect?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
  }

  export type InventoryPurchaseUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<InventoryPurchaseCreateWithoutEmployeeInput, InventoryPurchaseUncheckedCreateWithoutEmployeeInput> | InventoryPurchaseCreateWithoutEmployeeInput[] | InventoryPurchaseUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutEmployeeInput | InventoryPurchaseCreateOrConnectWithoutEmployeeInput[]
    createMany?: InventoryPurchaseCreateManyEmployeeInputEnvelope
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
  }

  export type WithdrawalLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WithdrawalLogCreateWithoutEmployeeInput, WithdrawalLogUncheckedCreateWithoutEmployeeInput> | WithdrawalLogCreateWithoutEmployeeInput[] | WithdrawalLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WithdrawalLogCreateOrConnectWithoutEmployeeInput | WithdrawalLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: WithdrawalLogCreateManyEmployeeInputEnvelope
    connect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
  }

  export type WorkLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WorkLogCreateWithoutEmployeeInput, WorkLogUncheckedCreateWithoutEmployeeInput> | WorkLogCreateWithoutEmployeeInput[] | WorkLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkLogCreateOrConnectWithoutEmployeeInput | WorkLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: WorkLogCreateManyEmployeeInputEnvelope
    connect?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
  }

  export type InventoryPurchaseUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<InventoryPurchaseCreateWithoutEmployeeInput, InventoryPurchaseUncheckedCreateWithoutEmployeeInput> | InventoryPurchaseCreateWithoutEmployeeInput[] | InventoryPurchaseUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutEmployeeInput | InventoryPurchaseCreateOrConnectWithoutEmployeeInput[]
    upsert?: InventoryPurchaseUpsertWithWhereUniqueWithoutEmployeeInput | InventoryPurchaseUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: InventoryPurchaseCreateManyEmployeeInputEnvelope
    set?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    disconnect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    delete?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    update?: InventoryPurchaseUpdateWithWhereUniqueWithoutEmployeeInput | InventoryPurchaseUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: InventoryPurchaseUpdateManyWithWhereWithoutEmployeeInput | InventoryPurchaseUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: InventoryPurchaseScalarWhereInput | InventoryPurchaseScalarWhereInput[]
  }

  export type WithdrawalLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WithdrawalLogCreateWithoutEmployeeInput, WithdrawalLogUncheckedCreateWithoutEmployeeInput> | WithdrawalLogCreateWithoutEmployeeInput[] | WithdrawalLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WithdrawalLogCreateOrConnectWithoutEmployeeInput | WithdrawalLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: WithdrawalLogUpsertWithWhereUniqueWithoutEmployeeInput | WithdrawalLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WithdrawalLogCreateManyEmployeeInputEnvelope
    set?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    disconnect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    delete?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    connect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    update?: WithdrawalLogUpdateWithWhereUniqueWithoutEmployeeInput | WithdrawalLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WithdrawalLogUpdateManyWithWhereWithoutEmployeeInput | WithdrawalLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WithdrawalLogScalarWhereInput | WithdrawalLogScalarWhereInput[]
  }

  export type WorkLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WorkLogCreateWithoutEmployeeInput, WorkLogUncheckedCreateWithoutEmployeeInput> | WorkLogCreateWithoutEmployeeInput[] | WorkLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkLogCreateOrConnectWithoutEmployeeInput | WorkLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: WorkLogUpsertWithWhereUniqueWithoutEmployeeInput | WorkLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WorkLogCreateManyEmployeeInputEnvelope
    set?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
    disconnect?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
    delete?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
    connect?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
    update?: WorkLogUpdateWithWhereUniqueWithoutEmployeeInput | WorkLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WorkLogUpdateManyWithWhereWithoutEmployeeInput | WorkLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WorkLogScalarWhereInput | WorkLogScalarWhereInput[]
  }

  export type InventoryPurchaseUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<InventoryPurchaseCreateWithoutEmployeeInput, InventoryPurchaseUncheckedCreateWithoutEmployeeInput> | InventoryPurchaseCreateWithoutEmployeeInput[] | InventoryPurchaseUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: InventoryPurchaseCreateOrConnectWithoutEmployeeInput | InventoryPurchaseCreateOrConnectWithoutEmployeeInput[]
    upsert?: InventoryPurchaseUpsertWithWhereUniqueWithoutEmployeeInput | InventoryPurchaseUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: InventoryPurchaseCreateManyEmployeeInputEnvelope
    set?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    disconnect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    delete?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    connect?: InventoryPurchaseWhereUniqueInput | InventoryPurchaseWhereUniqueInput[]
    update?: InventoryPurchaseUpdateWithWhereUniqueWithoutEmployeeInput | InventoryPurchaseUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: InventoryPurchaseUpdateManyWithWhereWithoutEmployeeInput | InventoryPurchaseUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: InventoryPurchaseScalarWhereInput | InventoryPurchaseScalarWhereInput[]
  }

  export type WithdrawalLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WithdrawalLogCreateWithoutEmployeeInput, WithdrawalLogUncheckedCreateWithoutEmployeeInput> | WithdrawalLogCreateWithoutEmployeeInput[] | WithdrawalLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WithdrawalLogCreateOrConnectWithoutEmployeeInput | WithdrawalLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: WithdrawalLogUpsertWithWhereUniqueWithoutEmployeeInput | WithdrawalLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WithdrawalLogCreateManyEmployeeInputEnvelope
    set?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    disconnect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    delete?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    connect?: WithdrawalLogWhereUniqueInput | WithdrawalLogWhereUniqueInput[]
    update?: WithdrawalLogUpdateWithWhereUniqueWithoutEmployeeInput | WithdrawalLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WithdrawalLogUpdateManyWithWhereWithoutEmployeeInput | WithdrawalLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WithdrawalLogScalarWhereInput | WithdrawalLogScalarWhereInput[]
  }

  export type WorkLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WorkLogCreateWithoutEmployeeInput, WorkLogUncheckedCreateWithoutEmployeeInput> | WorkLogCreateWithoutEmployeeInput[] | WorkLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkLogCreateOrConnectWithoutEmployeeInput | WorkLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: WorkLogUpsertWithWhereUniqueWithoutEmployeeInput | WorkLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WorkLogCreateManyEmployeeInputEnvelope
    set?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
    disconnect?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
    delete?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
    connect?: WorkLogWhereUniqueInput | WorkLogWhereUniqueInput[]
    update?: WorkLogUpdateWithWhereUniqueWithoutEmployeeInput | WorkLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WorkLogUpdateManyWithWhereWithoutEmployeeInput | WorkLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WorkLogScalarWhereInput | WorkLogScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutWork_LogsInput = {
    create?: XOR<EmployeeCreateWithoutWork_LogsInput, EmployeeUncheckedCreateWithoutWork_LogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWork_LogsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutWork_LogsNestedInput = {
    create?: XOR<EmployeeCreateWithoutWork_LogsInput, EmployeeUncheckedCreateWithoutWork_LogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWork_LogsInput
    upsert?: EmployeeUpsertWithoutWork_LogsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWork_LogsInput, EmployeeUpdateWithoutWork_LogsInput>, EmployeeUncheckedUpdateWithoutWork_LogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SupplierCreateWithoutSupplied_ProductsInput = {
    Supplier_Name: string
    Contact_Name?: string | null
    Contact_Phone_Number?: string | null
    Contact_Email?: string | null
    Notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplied_Stock_Batches?: StockBatchCreateNestedManyWithoutSupplierInput
    Supplied_Purchases?: InventoryPurchaseCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutSupplied_ProductsInput = {
    Supplier_Id?: number
    Supplier_Name: string
    Contact_Name?: string | null
    Contact_Phone_Number?: string | null
    Contact_Email?: string | null
    Notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplied_Stock_Batches?: StockBatchUncheckedCreateNestedManyWithoutSupplierInput
    Supplied_Purchases?: InventoryPurchaseUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutSupplied_ProductsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutSupplied_ProductsInput, SupplierUncheckedCreateWithoutSupplied_ProductsInput>
  }

  export type InventoryPurchaseCreateWithoutInventoryInput = {
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplier?: SupplierCreateNestedOneWithoutSupplied_PurchasesInput
    Employee?: EmployeeCreateNestedOneWithoutInventory_PackagesInput
  }

  export type InventoryPurchaseUncheckedCreateWithoutInventoryInput = {
    Purchase_Id?: number
    Employee_Id?: number | null
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type InventoryPurchaseCreateOrConnectWithoutInventoryInput = {
    where: InventoryPurchaseWhereUniqueInput
    create: XOR<InventoryPurchaseCreateWithoutInventoryInput, InventoryPurchaseUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryPurchaseCreateManyInventoryInputEnvelope = {
    data: InventoryPurchaseCreateManyInventoryInput | InventoryPurchaseCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type WithdrawalLogCreateWithoutInventoryInput = {
    Withdrawal_Reason?: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn?: Date | string
    updatedAt?: Date | string | null
    Employee?: EmployeeCreateNestedOneWithoutWithdrawal_LogsInput
  }

  export type WithdrawalLogUncheckedCreateWithoutInventoryInput = {
    WithdrawalLog_Id?: number
    Employee_Id?: number | null
    Withdrawal_Reason?: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalLogCreateOrConnectWithoutInventoryInput = {
    where: WithdrawalLogWhereUniqueInput
    create: XOR<WithdrawalLogCreateWithoutInventoryInput, WithdrawalLogUncheckedCreateWithoutInventoryInput>
  }

  export type WithdrawalLogCreateManyInventoryInputEnvelope = {
    data: WithdrawalLogCreateManyInventoryInput | WithdrawalLogCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type StockBatchCreateWithoutInventoryInput = {
    Batch_Number: string
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date?: Date | string | null
    Remaining_Quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplier?: SupplierCreateNestedOneWithoutSupplied_Stock_BatchesInput
  }

  export type StockBatchUncheckedCreateWithoutInventoryInput = {
    StockBatch_Id?: number
    Batch_Number: string
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date?: Date | string | null
    Remaining_Quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockBatchCreateOrConnectWithoutInventoryInput = {
    where: StockBatchWhereUniqueInput
    create: XOR<StockBatchCreateWithoutInventoryInput, StockBatchUncheckedCreateWithoutInventoryInput>
  }

  export type StockBatchCreateManyInventoryInputEnvelope = {
    data: StockBatchCreateManyInventoryInput | StockBatchCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type SupplierUpsertWithoutSupplied_ProductsInput = {
    update: XOR<SupplierUpdateWithoutSupplied_ProductsInput, SupplierUncheckedUpdateWithoutSupplied_ProductsInput>
    create: XOR<SupplierCreateWithoutSupplied_ProductsInput, SupplierUncheckedCreateWithoutSupplied_ProductsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutSupplied_ProductsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutSupplied_ProductsInput, SupplierUncheckedUpdateWithoutSupplied_ProductsInput>
  }

  export type SupplierUpdateWithoutSupplied_ProductsInput = {
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplied_Stock_Batches?: StockBatchUpdateManyWithoutSupplierNestedInput
    Supplied_Purchases?: InventoryPurchaseUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutSupplied_ProductsInput = {
    Supplier_Id?: IntFieldUpdateOperationsInput | number
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplied_Stock_Batches?: StockBatchUncheckedUpdateManyWithoutSupplierNestedInput
    Supplied_Purchases?: InventoryPurchaseUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type InventoryPurchaseUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryPurchaseWhereUniqueInput
    update: XOR<InventoryPurchaseUpdateWithoutInventoryInput, InventoryPurchaseUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryPurchaseCreateWithoutInventoryInput, InventoryPurchaseUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryPurchaseUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryPurchaseWhereUniqueInput
    data: XOR<InventoryPurchaseUpdateWithoutInventoryInput, InventoryPurchaseUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryPurchaseUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryPurchaseScalarWhereInput
    data: XOR<InventoryPurchaseUpdateManyMutationInput, InventoryPurchaseUncheckedUpdateManyWithoutInventoryInput>
  }

  export type InventoryPurchaseScalarWhereInput = {
    AND?: InventoryPurchaseScalarWhereInput | InventoryPurchaseScalarWhereInput[]
    OR?: InventoryPurchaseScalarWhereInput[]
    NOT?: InventoryPurchaseScalarWhereInput | InventoryPurchaseScalarWhereInput[]
    Purchase_Id?: IntFilter<"InventoryPurchase"> | number
    Inventory_Id?: IntFilter<"InventoryPurchase"> | number
    Employee_Id?: IntNullableFilter<"InventoryPurchase"> | number | null
    Supplier_Id?: IntNullableFilter<"InventoryPurchase"> | number | null
    Purchase_Date?: DateTimeFilter<"InventoryPurchase"> | Date | string
    Quantity_Purchased?: IntFilter<"InventoryPurchase"> | number
    Total_Cost?: FloatNullableFilter<"InventoryPurchase"> | number | null
    Unit_Price?: FloatNullableFilter<"InventoryPurchase"> | number | null
    createdAt?: DateTimeFilter<"InventoryPurchase"> | Date | string
    updatedAt?: DateTimeNullableFilter<"InventoryPurchase"> | Date | string | null
  }

  export type WithdrawalLogUpsertWithWhereUniqueWithoutInventoryInput = {
    where: WithdrawalLogWhereUniqueInput
    update: XOR<WithdrawalLogUpdateWithoutInventoryInput, WithdrawalLogUncheckedUpdateWithoutInventoryInput>
    create: XOR<WithdrawalLogCreateWithoutInventoryInput, WithdrawalLogUncheckedCreateWithoutInventoryInput>
  }

  export type WithdrawalLogUpdateWithWhereUniqueWithoutInventoryInput = {
    where: WithdrawalLogWhereUniqueInput
    data: XOR<WithdrawalLogUpdateWithoutInventoryInput, WithdrawalLogUncheckedUpdateWithoutInventoryInput>
  }

  export type WithdrawalLogUpdateManyWithWhereWithoutInventoryInput = {
    where: WithdrawalLogScalarWhereInput
    data: XOR<WithdrawalLogUpdateManyMutationInput, WithdrawalLogUncheckedUpdateManyWithoutInventoryInput>
  }

  export type WithdrawalLogScalarWhereInput = {
    AND?: WithdrawalLogScalarWhereInput | WithdrawalLogScalarWhereInput[]
    OR?: WithdrawalLogScalarWhereInput[]
    NOT?: WithdrawalLogScalarWhereInput | WithdrawalLogScalarWhereInput[]
    WithdrawalLog_Id?: IntFilter<"WithdrawalLog"> | number
    Inventory_Id?: IntFilter<"WithdrawalLog"> | number
    Employee_Id?: IntNullableFilter<"WithdrawalLog"> | number | null
    Withdrawal_Reason?: StringNullableFilter<"WithdrawalLog"> | string | null
    Quantity_Withdrawn?: IntFilter<"WithdrawalLog"> | number
    Date_Withdrawn?: DateTimeFilter<"WithdrawalLog"> | Date | string
    updatedAt?: DateTimeNullableFilter<"WithdrawalLog"> | Date | string | null
  }

  export type StockBatchUpsertWithWhereUniqueWithoutInventoryInput = {
    where: StockBatchWhereUniqueInput
    update: XOR<StockBatchUpdateWithoutInventoryInput, StockBatchUncheckedUpdateWithoutInventoryInput>
    create: XOR<StockBatchCreateWithoutInventoryInput, StockBatchUncheckedCreateWithoutInventoryInput>
  }

  export type StockBatchUpdateWithWhereUniqueWithoutInventoryInput = {
    where: StockBatchWhereUniqueInput
    data: XOR<StockBatchUpdateWithoutInventoryInput, StockBatchUncheckedUpdateWithoutInventoryInput>
  }

  export type StockBatchUpdateManyWithWhereWithoutInventoryInput = {
    where: StockBatchScalarWhereInput
    data: XOR<StockBatchUpdateManyMutationInput, StockBatchUncheckedUpdateManyWithoutInventoryInput>
  }

  export type StockBatchScalarWhereInput = {
    AND?: StockBatchScalarWhereInput | StockBatchScalarWhereInput[]
    OR?: StockBatchScalarWhereInput[]
    NOT?: StockBatchScalarWhereInput | StockBatchScalarWhereInput[]
    StockBatch_Id?: IntFilter<"StockBatch"> | number
    Batch_Number?: StringFilter<"StockBatch"> | string
    Inventory_Id?: IntFilter<"StockBatch"> | number
    Supplier_Id?: IntNullableFilter<"StockBatch"> | number | null
    Purchase_Date?: DateTimeFilter<"StockBatch"> | Date | string
    Quantity_Purchased?: IntFilter<"StockBatch"> | number
    Unit_Price?: FloatFilter<"StockBatch"> | number
    Expiry_Date?: DateTimeNullableFilter<"StockBatch"> | Date | string | null
    Remaining_Quantity?: IntFilter<"StockBatch"> | number
    createdAt?: DateTimeFilter<"StockBatch"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockBatch"> | Date | string | null
  }

  export type InventoryCreateWithoutWithdrawal_LogsInput = {
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplier?: SupplierCreateNestedOneWithoutSupplied_ProductsInput
    Inventory_Purchases?: InventoryPurchaseCreateNestedManyWithoutInventoryInput
    Stock_Batches?: StockBatchCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutWithdrawal_LogsInput = {
    Inventory_Id?: number
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    Supplier_Id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Purchases?: InventoryPurchaseUncheckedCreateNestedManyWithoutInventoryInput
    Stock_Batches?: StockBatchUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutWithdrawal_LogsInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutWithdrawal_LogsInput, InventoryUncheckedCreateWithoutWithdrawal_LogsInput>
  }

  export type EmployeeCreateWithoutWithdrawal_LogsInput = {
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image?: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonNullValueInput | InputJsonValue
    About_Employee?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Packages?: InventoryPurchaseCreateNestedManyWithoutEmployeeInput
    Work_Logs?: WorkLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutWithdrawal_LogsInput = {
    Employee_Id?: number
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image?: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonNullValueInput | InputJsonValue
    About_Employee?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Packages?: InventoryPurchaseUncheckedCreateNestedManyWithoutEmployeeInput
    Work_Logs?: WorkLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutWithdrawal_LogsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWithdrawal_LogsInput, EmployeeUncheckedCreateWithoutWithdrawal_LogsInput>
  }

  export type InventoryUpsertWithoutWithdrawal_LogsInput = {
    update: XOR<InventoryUpdateWithoutWithdrawal_LogsInput, InventoryUncheckedUpdateWithoutWithdrawal_LogsInput>
    create: XOR<InventoryCreateWithoutWithdrawal_LogsInput, InventoryUncheckedCreateWithoutWithdrawal_LogsInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutWithdrawal_LogsInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutWithdrawal_LogsInput, InventoryUncheckedUpdateWithoutWithdrawal_LogsInput>
  }

  export type InventoryUpdateWithoutWithdrawal_LogsInput = {
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplier?: SupplierUpdateOneWithoutSupplied_ProductsNestedInput
    Inventory_Purchases?: InventoryPurchaseUpdateManyWithoutInventoryNestedInput
    Stock_Batches?: StockBatchUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutWithdrawal_LogsInput = {
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Purchases?: InventoryPurchaseUncheckedUpdateManyWithoutInventoryNestedInput
    Stock_Batches?: StockBatchUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type EmployeeUpsertWithoutWithdrawal_LogsInput = {
    update: XOR<EmployeeUpdateWithoutWithdrawal_LogsInput, EmployeeUncheckedUpdateWithoutWithdrawal_LogsInput>
    create: XOR<EmployeeCreateWithoutWithdrawal_LogsInput, EmployeeUncheckedCreateWithoutWithdrawal_LogsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWithdrawal_LogsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWithdrawal_LogsInput, EmployeeUncheckedUpdateWithoutWithdrawal_LogsInput>
  }

  export type EmployeeUpdateWithoutWithdrawal_LogsInput = {
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Packages?: InventoryPurchaseUpdateManyWithoutEmployeeNestedInput
    Work_Logs?: WorkLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWithdrawal_LogsInput = {
    Employee_Id?: IntFieldUpdateOperationsInput | number
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Packages?: InventoryPurchaseUncheckedUpdateManyWithoutEmployeeNestedInput
    Work_Logs?: WorkLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type InventoryCreateWithoutInventory_PurchasesInput = {
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplier?: SupplierCreateNestedOneWithoutSupplied_ProductsInput
    Withdrawal_Logs?: WithdrawalLogCreateNestedManyWithoutInventoryInput
    Stock_Batches?: StockBatchCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutInventory_PurchasesInput = {
    Inventory_Id?: number
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    Supplier_Id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Withdrawal_Logs?: WithdrawalLogUncheckedCreateNestedManyWithoutInventoryInput
    Stock_Batches?: StockBatchUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutInventory_PurchasesInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventory_PurchasesInput, InventoryUncheckedCreateWithoutInventory_PurchasesInput>
  }

  export type SupplierCreateWithoutSupplied_PurchasesInput = {
    Supplier_Name: string
    Contact_Name?: string | null
    Contact_Phone_Number?: string | null
    Contact_Email?: string | null
    Notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplied_Products?: InventoryCreateNestedManyWithoutSupplierInput
    Supplied_Stock_Batches?: StockBatchCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutSupplied_PurchasesInput = {
    Supplier_Id?: number
    Supplier_Name: string
    Contact_Name?: string | null
    Contact_Phone_Number?: string | null
    Contact_Email?: string | null
    Notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplied_Products?: InventoryUncheckedCreateNestedManyWithoutSupplierInput
    Supplied_Stock_Batches?: StockBatchUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutSupplied_PurchasesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutSupplied_PurchasesInput, SupplierUncheckedCreateWithoutSupplied_PurchasesInput>
  }

  export type EmployeeCreateWithoutInventory_PackagesInput = {
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image?: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonNullValueInput | InputJsonValue
    About_Employee?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Withdrawal_Logs?: WithdrawalLogCreateNestedManyWithoutEmployeeInput
    Work_Logs?: WorkLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutInventory_PackagesInput = {
    Employee_Id?: number
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image?: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonNullValueInput | InputJsonValue
    About_Employee?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Withdrawal_Logs?: WithdrawalLogUncheckedCreateNestedManyWithoutEmployeeInput
    Work_Logs?: WorkLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutInventory_PackagesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutInventory_PackagesInput, EmployeeUncheckedCreateWithoutInventory_PackagesInput>
  }

  export type InventoryUpsertWithoutInventory_PurchasesInput = {
    update: XOR<InventoryUpdateWithoutInventory_PurchasesInput, InventoryUncheckedUpdateWithoutInventory_PurchasesInput>
    create: XOR<InventoryCreateWithoutInventory_PurchasesInput, InventoryUncheckedCreateWithoutInventory_PurchasesInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutInventory_PurchasesInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutInventory_PurchasesInput, InventoryUncheckedUpdateWithoutInventory_PurchasesInput>
  }

  export type InventoryUpdateWithoutInventory_PurchasesInput = {
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplier?: SupplierUpdateOneWithoutSupplied_ProductsNestedInput
    Withdrawal_Logs?: WithdrawalLogUpdateManyWithoutInventoryNestedInput
    Stock_Batches?: StockBatchUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventory_PurchasesInput = {
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Withdrawal_Logs?: WithdrawalLogUncheckedUpdateManyWithoutInventoryNestedInput
    Stock_Batches?: StockBatchUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type SupplierUpsertWithoutSupplied_PurchasesInput = {
    update: XOR<SupplierUpdateWithoutSupplied_PurchasesInput, SupplierUncheckedUpdateWithoutSupplied_PurchasesInput>
    create: XOR<SupplierCreateWithoutSupplied_PurchasesInput, SupplierUncheckedCreateWithoutSupplied_PurchasesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutSupplied_PurchasesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutSupplied_PurchasesInput, SupplierUncheckedUpdateWithoutSupplied_PurchasesInput>
  }

  export type SupplierUpdateWithoutSupplied_PurchasesInput = {
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplied_Products?: InventoryUpdateManyWithoutSupplierNestedInput
    Supplied_Stock_Batches?: StockBatchUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutSupplied_PurchasesInput = {
    Supplier_Id?: IntFieldUpdateOperationsInput | number
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplied_Products?: InventoryUncheckedUpdateManyWithoutSupplierNestedInput
    Supplied_Stock_Batches?: StockBatchUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type EmployeeUpsertWithoutInventory_PackagesInput = {
    update: XOR<EmployeeUpdateWithoutInventory_PackagesInput, EmployeeUncheckedUpdateWithoutInventory_PackagesInput>
    create: XOR<EmployeeCreateWithoutInventory_PackagesInput, EmployeeUncheckedCreateWithoutInventory_PackagesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutInventory_PackagesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutInventory_PackagesInput, EmployeeUncheckedUpdateWithoutInventory_PackagesInput>
  }

  export type EmployeeUpdateWithoutInventory_PackagesInput = {
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Withdrawal_Logs?: WithdrawalLogUpdateManyWithoutEmployeeNestedInput
    Work_Logs?: WorkLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutInventory_PackagesInput = {
    Employee_Id?: IntFieldUpdateOperationsInput | number
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Withdrawal_Logs?: WithdrawalLogUncheckedUpdateManyWithoutEmployeeNestedInput
    Work_Logs?: WorkLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type InventoryCreateWithoutStock_BatchesInput = {
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplier?: SupplierCreateNestedOneWithoutSupplied_ProductsInput
    Inventory_Purchases?: InventoryPurchaseCreateNestedManyWithoutInventoryInput
    Withdrawal_Logs?: WithdrawalLogCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutStock_BatchesInput = {
    Inventory_Id?: number
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    Supplier_Id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Purchases?: InventoryPurchaseUncheckedCreateNestedManyWithoutInventoryInput
    Withdrawal_Logs?: WithdrawalLogUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutStock_BatchesInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutStock_BatchesInput, InventoryUncheckedCreateWithoutStock_BatchesInput>
  }

  export type SupplierCreateWithoutSupplied_Stock_BatchesInput = {
    Supplier_Name: string
    Contact_Name?: string | null
    Contact_Phone_Number?: string | null
    Contact_Email?: string | null
    Notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplied_Products?: InventoryCreateNestedManyWithoutSupplierInput
    Supplied_Purchases?: InventoryPurchaseCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutSupplied_Stock_BatchesInput = {
    Supplier_Id?: number
    Supplier_Name: string
    Contact_Name?: string | null
    Contact_Phone_Number?: string | null
    Contact_Email?: string | null
    Notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Supplied_Products?: InventoryUncheckedCreateNestedManyWithoutSupplierInput
    Supplied_Purchases?: InventoryPurchaseUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutSupplied_Stock_BatchesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutSupplied_Stock_BatchesInput, SupplierUncheckedCreateWithoutSupplied_Stock_BatchesInput>
  }

  export type InventoryUpsertWithoutStock_BatchesInput = {
    update: XOR<InventoryUpdateWithoutStock_BatchesInput, InventoryUncheckedUpdateWithoutStock_BatchesInput>
    create: XOR<InventoryCreateWithoutStock_BatchesInput, InventoryUncheckedCreateWithoutStock_BatchesInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutStock_BatchesInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutStock_BatchesInput, InventoryUncheckedUpdateWithoutStock_BatchesInput>
  }

  export type InventoryUpdateWithoutStock_BatchesInput = {
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplier?: SupplierUpdateOneWithoutSupplied_ProductsNestedInput
    Inventory_Purchases?: InventoryPurchaseUpdateManyWithoutInventoryNestedInput
    Withdrawal_Logs?: WithdrawalLogUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutStock_BatchesInput = {
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Purchases?: InventoryPurchaseUncheckedUpdateManyWithoutInventoryNestedInput
    Withdrawal_Logs?: WithdrawalLogUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type SupplierUpsertWithoutSupplied_Stock_BatchesInput = {
    update: XOR<SupplierUpdateWithoutSupplied_Stock_BatchesInput, SupplierUncheckedUpdateWithoutSupplied_Stock_BatchesInput>
    create: XOR<SupplierCreateWithoutSupplied_Stock_BatchesInput, SupplierUncheckedCreateWithoutSupplied_Stock_BatchesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutSupplied_Stock_BatchesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutSupplied_Stock_BatchesInput, SupplierUncheckedUpdateWithoutSupplied_Stock_BatchesInput>
  }

  export type SupplierUpdateWithoutSupplied_Stock_BatchesInput = {
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplied_Products?: InventoryUpdateManyWithoutSupplierNestedInput
    Supplied_Purchases?: InventoryPurchaseUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutSupplied_Stock_BatchesInput = {
    Supplier_Id?: IntFieldUpdateOperationsInput | number
    Supplier_Name?: StringFieldUpdateOperationsInput | string
    Contact_Name?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Phone_Number?: NullableStringFieldUpdateOperationsInput | string | null
    Contact_Email?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplied_Products?: InventoryUncheckedUpdateManyWithoutSupplierNestedInput
    Supplied_Purchases?: InventoryPurchaseUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type InventoryCreateWithoutSupplierInput = {
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Purchases?: InventoryPurchaseCreateNestedManyWithoutInventoryInput
    Withdrawal_Logs?: WithdrawalLogCreateNestedManyWithoutInventoryInput
    Stock_Batches?: StockBatchCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutSupplierInput = {
    Inventory_Id?: number
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Purchases?: InventoryPurchaseUncheckedCreateNestedManyWithoutInventoryInput
    Withdrawal_Logs?: WithdrawalLogUncheckedCreateNestedManyWithoutInventoryInput
    Stock_Batches?: StockBatchUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutSupplierInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutSupplierInput, InventoryUncheckedCreateWithoutSupplierInput>
  }

  export type InventoryCreateManySupplierInputEnvelope = {
    data: InventoryCreateManySupplierInput | InventoryCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type StockBatchCreateWithoutSupplierInput = {
    Batch_Number: string
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date?: Date | string | null
    Remaining_Quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory: InventoryCreateNestedOneWithoutStock_BatchesInput
  }

  export type StockBatchUncheckedCreateWithoutSupplierInput = {
    StockBatch_Id?: number
    Batch_Number: string
    Inventory_Id: number
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date?: Date | string | null
    Remaining_Quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockBatchCreateOrConnectWithoutSupplierInput = {
    where: StockBatchWhereUniqueInput
    create: XOR<StockBatchCreateWithoutSupplierInput, StockBatchUncheckedCreateWithoutSupplierInput>
  }

  export type StockBatchCreateManySupplierInputEnvelope = {
    data: StockBatchCreateManySupplierInput | StockBatchCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type InventoryPurchaseCreateWithoutSupplierInput = {
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory: InventoryCreateNestedOneWithoutInventory_PurchasesInput
    Employee?: EmployeeCreateNestedOneWithoutInventory_PackagesInput
  }

  export type InventoryPurchaseUncheckedCreateWithoutSupplierInput = {
    Purchase_Id?: number
    Inventory_Id: number
    Employee_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type InventoryPurchaseCreateOrConnectWithoutSupplierInput = {
    where: InventoryPurchaseWhereUniqueInput
    create: XOR<InventoryPurchaseCreateWithoutSupplierInput, InventoryPurchaseUncheckedCreateWithoutSupplierInput>
  }

  export type InventoryPurchaseCreateManySupplierInputEnvelope = {
    data: InventoryPurchaseCreateManySupplierInput | InventoryPurchaseCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type InventoryUpsertWithWhereUniqueWithoutSupplierInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutSupplierInput, InventoryUncheckedUpdateWithoutSupplierInput>
    create: XOR<InventoryCreateWithoutSupplierInput, InventoryUncheckedCreateWithoutSupplierInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutSupplierInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutSupplierInput, InventoryUncheckedUpdateWithoutSupplierInput>
  }

  export type InventoryUpdateManyWithWhereWithoutSupplierInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutSupplierInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    Inventory_Id?: IntFilter<"Inventory"> | number
    Product_Name?: StringFilter<"Inventory"> | string
    Product_Category?: StringFilter<"Inventory"> | string
    Product_Description?: StringNullableFilter<"Inventory"> | string | null
    Is_Discontinued?: BoolFilter<"Inventory"> | boolean
    Stock_Quantity?: IntFilter<"Inventory"> | number
    Reorder_Threshold?: IntNullableFilter<"Inventory"> | number | null
    Total_Value?: FloatNullableFilter<"Inventory"> | number | null
    Unit_Of_Measurement?: StringFilter<"Inventory"> | string
    Unit_Price?: FloatNullableFilter<"Inventory"> | number | null
    Stock_Status?: StringNullableFilter<"Inventory"> | string | null
    Storage_Location?: StringNullableFilter<"Inventory"> | string | null
    Expiry_Date?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    Initial_Stock_Quantity?: IntNullableFilter<"Inventory"> | number | null
    Supplier_Id?: IntNullableFilter<"Inventory"> | number | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Inventory"> | Date | string | null
  }

  export type StockBatchUpsertWithWhereUniqueWithoutSupplierInput = {
    where: StockBatchWhereUniqueInput
    update: XOR<StockBatchUpdateWithoutSupplierInput, StockBatchUncheckedUpdateWithoutSupplierInput>
    create: XOR<StockBatchCreateWithoutSupplierInput, StockBatchUncheckedCreateWithoutSupplierInput>
  }

  export type StockBatchUpdateWithWhereUniqueWithoutSupplierInput = {
    where: StockBatchWhereUniqueInput
    data: XOR<StockBatchUpdateWithoutSupplierInput, StockBatchUncheckedUpdateWithoutSupplierInput>
  }

  export type StockBatchUpdateManyWithWhereWithoutSupplierInput = {
    where: StockBatchScalarWhereInput
    data: XOR<StockBatchUpdateManyMutationInput, StockBatchUncheckedUpdateManyWithoutSupplierInput>
  }

  export type InventoryPurchaseUpsertWithWhereUniqueWithoutSupplierInput = {
    where: InventoryPurchaseWhereUniqueInput
    update: XOR<InventoryPurchaseUpdateWithoutSupplierInput, InventoryPurchaseUncheckedUpdateWithoutSupplierInput>
    create: XOR<InventoryPurchaseCreateWithoutSupplierInput, InventoryPurchaseUncheckedCreateWithoutSupplierInput>
  }

  export type InventoryPurchaseUpdateWithWhereUniqueWithoutSupplierInput = {
    where: InventoryPurchaseWhereUniqueInput
    data: XOR<InventoryPurchaseUpdateWithoutSupplierInput, InventoryPurchaseUncheckedUpdateWithoutSupplierInput>
  }

  export type InventoryPurchaseUpdateManyWithWhereWithoutSupplierInput = {
    where: InventoryPurchaseScalarWhereInput
    data: XOR<InventoryPurchaseUpdateManyMutationInput, InventoryPurchaseUncheckedUpdateManyWithoutSupplierInput>
  }

  export type InventoryPurchaseCreateWithoutEmployeeInput = {
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory: InventoryCreateNestedOneWithoutInventory_PurchasesInput
    Supplier?: SupplierCreateNestedOneWithoutSupplied_PurchasesInput
  }

  export type InventoryPurchaseUncheckedCreateWithoutEmployeeInput = {
    Purchase_Id?: number
    Inventory_Id: number
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type InventoryPurchaseCreateOrConnectWithoutEmployeeInput = {
    where: InventoryPurchaseWhereUniqueInput
    create: XOR<InventoryPurchaseCreateWithoutEmployeeInput, InventoryPurchaseUncheckedCreateWithoutEmployeeInput>
  }

  export type InventoryPurchaseCreateManyEmployeeInputEnvelope = {
    data: InventoryPurchaseCreateManyEmployeeInput | InventoryPurchaseCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type WithdrawalLogCreateWithoutEmployeeInput = {
    Withdrawal_Reason?: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn?: Date | string
    updatedAt?: Date | string | null
    Inventory: InventoryCreateNestedOneWithoutWithdrawal_LogsInput
  }

  export type WithdrawalLogUncheckedCreateWithoutEmployeeInput = {
    WithdrawalLog_Id?: number
    Inventory_Id: number
    Withdrawal_Reason?: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalLogCreateOrConnectWithoutEmployeeInput = {
    where: WithdrawalLogWhereUniqueInput
    create: XOR<WithdrawalLogCreateWithoutEmployeeInput, WithdrawalLogUncheckedCreateWithoutEmployeeInput>
  }

  export type WithdrawalLogCreateManyEmployeeInputEnvelope = {
    data: WithdrawalLogCreateManyEmployeeInput | WithdrawalLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type WorkLogCreateWithoutEmployeeInput = {
    Login_Time?: Date | string
    Logout_Time?: Date | string | null
  }

  export type WorkLogUncheckedCreateWithoutEmployeeInput = {
    WorkLog_Id?: number
    Login_Time?: Date | string
    Logout_Time?: Date | string | null
  }

  export type WorkLogCreateOrConnectWithoutEmployeeInput = {
    where: WorkLogWhereUniqueInput
    create: XOR<WorkLogCreateWithoutEmployeeInput, WorkLogUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkLogCreateManyEmployeeInputEnvelope = {
    data: WorkLogCreateManyEmployeeInput | WorkLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type InventoryPurchaseUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: InventoryPurchaseWhereUniqueInput
    update: XOR<InventoryPurchaseUpdateWithoutEmployeeInput, InventoryPurchaseUncheckedUpdateWithoutEmployeeInput>
    create: XOR<InventoryPurchaseCreateWithoutEmployeeInput, InventoryPurchaseUncheckedCreateWithoutEmployeeInput>
  }

  export type InventoryPurchaseUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: InventoryPurchaseWhereUniqueInput
    data: XOR<InventoryPurchaseUpdateWithoutEmployeeInput, InventoryPurchaseUncheckedUpdateWithoutEmployeeInput>
  }

  export type InventoryPurchaseUpdateManyWithWhereWithoutEmployeeInput = {
    where: InventoryPurchaseScalarWhereInput
    data: XOR<InventoryPurchaseUpdateManyMutationInput, InventoryPurchaseUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type WithdrawalLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: WithdrawalLogWhereUniqueInput
    update: XOR<WithdrawalLogUpdateWithoutEmployeeInput, WithdrawalLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<WithdrawalLogCreateWithoutEmployeeInput, WithdrawalLogUncheckedCreateWithoutEmployeeInput>
  }

  export type WithdrawalLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: WithdrawalLogWhereUniqueInput
    data: XOR<WithdrawalLogUpdateWithoutEmployeeInput, WithdrawalLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type WithdrawalLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: WithdrawalLogScalarWhereInput
    data: XOR<WithdrawalLogUpdateManyMutationInput, WithdrawalLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type WorkLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: WorkLogWhereUniqueInput
    update: XOR<WorkLogUpdateWithoutEmployeeInput, WorkLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<WorkLogCreateWithoutEmployeeInput, WorkLogUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: WorkLogWhereUniqueInput
    data: XOR<WorkLogUpdateWithoutEmployeeInput, WorkLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type WorkLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: WorkLogScalarWhereInput
    data: XOR<WorkLogUpdateManyMutationInput, WorkLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type WorkLogScalarWhereInput = {
    AND?: WorkLogScalarWhereInput | WorkLogScalarWhereInput[]
    OR?: WorkLogScalarWhereInput[]
    NOT?: WorkLogScalarWhereInput | WorkLogScalarWhereInput[]
    WorkLog_Id?: IntFilter<"WorkLog"> | number
    Employee_Id?: IntFilter<"WorkLog"> | number
    Login_Time?: DateTimeFilter<"WorkLog"> | Date | string
    Logout_Time?: DateTimeNullableFilter<"WorkLog"> | Date | string | null
  }

  export type EmployeeCreateWithoutWork_LogsInput = {
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image?: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonNullValueInput | InputJsonValue
    About_Employee?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Packages?: InventoryPurchaseCreateNestedManyWithoutEmployeeInput
    Withdrawal_Logs?: WithdrawalLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutWork_LogsInput = {
    Employee_Id?: number
    First_Name: string
    Last_Name: string
    Gender: string
    Email: string
    Password: string
    Profile_Image?: string | null
    Phone_Number: string
    Job_Position: string
    Work_Shift: string
    Education_Details: string
    Work_Experience: string
    Monthly_Salary: number
    Address: JsonNullValueInput | InputJsonValue
    About_Employee?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Inventory_Packages?: InventoryPurchaseUncheckedCreateNestedManyWithoutEmployeeInput
    Withdrawal_Logs?: WithdrawalLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutWork_LogsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWork_LogsInput, EmployeeUncheckedCreateWithoutWork_LogsInput>
  }

  export type EmployeeUpsertWithoutWork_LogsInput = {
    update: XOR<EmployeeUpdateWithoutWork_LogsInput, EmployeeUncheckedUpdateWithoutWork_LogsInput>
    create: XOR<EmployeeCreateWithoutWork_LogsInput, EmployeeUncheckedCreateWithoutWork_LogsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWork_LogsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWork_LogsInput, EmployeeUncheckedUpdateWithoutWork_LogsInput>
  }

  export type EmployeeUpdateWithoutWork_LogsInput = {
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Packages?: InventoryPurchaseUpdateManyWithoutEmployeeNestedInput
    Withdrawal_Logs?: WithdrawalLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWork_LogsInput = {
    Employee_Id?: IntFieldUpdateOperationsInput | number
    First_Name?: StringFieldUpdateOperationsInput | string
    Last_Name?: StringFieldUpdateOperationsInput | string
    Gender?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Profile_Image?: NullableStringFieldUpdateOperationsInput | string | null
    Phone_Number?: StringFieldUpdateOperationsInput | string
    Job_Position?: StringFieldUpdateOperationsInput | string
    Work_Shift?: StringFieldUpdateOperationsInput | string
    Education_Details?: StringFieldUpdateOperationsInput | string
    Work_Experience?: StringFieldUpdateOperationsInput | string
    Monthly_Salary?: FloatFieldUpdateOperationsInput | number
    Address?: JsonNullValueInput | InputJsonValue
    About_Employee?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Packages?: InventoryPurchaseUncheckedUpdateManyWithoutEmployeeNestedInput
    Withdrawal_Logs?: WithdrawalLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type InventoryPurchaseCreateManyInventoryInput = {
    Purchase_Id?: number
    Employee_Id?: number | null
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalLogCreateManyInventoryInput = {
    WithdrawalLog_Id?: number
    Employee_Id?: number | null
    Withdrawal_Reason?: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockBatchCreateManyInventoryInput = {
    StockBatch_Id?: number
    Batch_Number: string
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date?: Date | string | null
    Remaining_Quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type InventoryPurchaseUpdateWithoutInventoryInput = {
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplier?: SupplierUpdateOneWithoutSupplied_PurchasesNestedInput
    Employee?: EmployeeUpdateOneWithoutInventory_PackagesNestedInput
  }

  export type InventoryPurchaseUncheckedUpdateWithoutInventoryInput = {
    Purchase_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryPurchaseUncheckedUpdateManyWithoutInventoryInput = {
    Purchase_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalLogUpdateWithoutInventoryInput = {
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Employee?: EmployeeUpdateOneWithoutWithdrawal_LogsNestedInput
  }

  export type WithdrawalLogUncheckedUpdateWithoutInventoryInput = {
    WithdrawalLog_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalLogUncheckedUpdateManyWithoutInventoryInput = {
    WithdrawalLog_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockBatchUpdateWithoutInventoryInput = {
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Supplier?: SupplierUpdateOneWithoutSupplied_Stock_BatchesNestedInput
  }

  export type StockBatchUncheckedUpdateWithoutInventoryInput = {
    StockBatch_Id?: IntFieldUpdateOperationsInput | number
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockBatchUncheckedUpdateManyWithoutInventoryInput = {
    StockBatch_Id?: IntFieldUpdateOperationsInput | number
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryCreateManySupplierInput = {
    Inventory_Id?: number
    Product_Name: string
    Product_Category: string
    Product_Description?: string | null
    Is_Discontinued?: boolean
    Stock_Quantity?: number
    Reorder_Threshold?: number | null
    Total_Value?: number | null
    Unit_Of_Measurement: string
    Unit_Price?: number | null
    Stock_Status?: string | null
    Storage_Location?: string | null
    Expiry_Date?: Date | string | null
    Initial_Stock_Quantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockBatchCreateManySupplierInput = {
    StockBatch_Id?: number
    Batch_Number: string
    Inventory_Id: number
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Unit_Price: number
    Expiry_Date?: Date | string | null
    Remaining_Quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type InventoryPurchaseCreateManySupplierInput = {
    Purchase_Id?: number
    Inventory_Id: number
    Employee_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type InventoryUpdateWithoutSupplierInput = {
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Purchases?: InventoryPurchaseUpdateManyWithoutInventoryNestedInput
    Withdrawal_Logs?: WithdrawalLogUpdateManyWithoutInventoryNestedInput
    Stock_Batches?: StockBatchUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutSupplierInput = {
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory_Purchases?: InventoryPurchaseUncheckedUpdateManyWithoutInventoryNestedInput
    Withdrawal_Logs?: WithdrawalLogUncheckedUpdateManyWithoutInventoryNestedInput
    Stock_Batches?: StockBatchUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutSupplierInput = {
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Product_Name?: StringFieldUpdateOperationsInput | string
    Product_Category?: StringFieldUpdateOperationsInput | string
    Product_Description?: NullableStringFieldUpdateOperationsInput | string | null
    Is_Discontinued?: BoolFieldUpdateOperationsInput | boolean
    Stock_Quantity?: IntFieldUpdateOperationsInput | number
    Reorder_Threshold?: NullableIntFieldUpdateOperationsInput | number | null
    Total_Value?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Of_Measurement?: StringFieldUpdateOperationsInput | string
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    Stock_Status?: NullableStringFieldUpdateOperationsInput | string | null
    Storage_Location?: NullableStringFieldUpdateOperationsInput | string | null
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Initial_Stock_Quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockBatchUpdateWithoutSupplierInput = {
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory?: InventoryUpdateOneRequiredWithoutStock_BatchesNestedInput
  }

  export type StockBatchUncheckedUpdateWithoutSupplierInput = {
    StockBatch_Id?: IntFieldUpdateOperationsInput | number
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockBatchUncheckedUpdateManyWithoutSupplierInput = {
    StockBatch_Id?: IntFieldUpdateOperationsInput | number
    Batch_Number?: StringFieldUpdateOperationsInput | string
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Unit_Price?: FloatFieldUpdateOperationsInput | number
    Expiry_Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Remaining_Quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryPurchaseUpdateWithoutSupplierInput = {
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory?: InventoryUpdateOneRequiredWithoutInventory_PurchasesNestedInput
    Employee?: EmployeeUpdateOneWithoutInventory_PackagesNestedInput
  }

  export type InventoryPurchaseUncheckedUpdateWithoutSupplierInput = {
    Purchase_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryPurchaseUncheckedUpdateManyWithoutSupplierInput = {
    Purchase_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Employee_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryPurchaseCreateManyEmployeeInput = {
    Purchase_Id?: number
    Inventory_Id: number
    Supplier_Id?: number | null
    Purchase_Date?: Date | string
    Quantity_Purchased: number
    Total_Cost?: number | null
    Unit_Price?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawalLogCreateManyEmployeeInput = {
    WithdrawalLog_Id?: number
    Inventory_Id: number
    Withdrawal_Reason?: string | null
    Quantity_Withdrawn: number
    Date_Withdrawn?: Date | string
    updatedAt?: Date | string | null
  }

  export type WorkLogCreateManyEmployeeInput = {
    WorkLog_Id?: number
    Login_Time?: Date | string
    Logout_Time?: Date | string | null
  }

  export type InventoryPurchaseUpdateWithoutEmployeeInput = {
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory?: InventoryUpdateOneRequiredWithoutInventory_PurchasesNestedInput
    Supplier?: SupplierUpdateOneWithoutSupplied_PurchasesNestedInput
  }

  export type InventoryPurchaseUncheckedUpdateWithoutEmployeeInput = {
    Purchase_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryPurchaseUncheckedUpdateManyWithoutEmployeeInput = {
    Purchase_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Supplier_Id?: NullableIntFieldUpdateOperationsInput | number | null
    Purchase_Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Quantity_Purchased?: IntFieldUpdateOperationsInput | number
    Total_Cost?: NullableFloatFieldUpdateOperationsInput | number | null
    Unit_Price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalLogUpdateWithoutEmployeeInput = {
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Inventory?: InventoryUpdateOneRequiredWithoutWithdrawal_LogsNestedInput
  }

  export type WithdrawalLogUncheckedUpdateWithoutEmployeeInput = {
    WithdrawalLog_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawalLogUncheckedUpdateManyWithoutEmployeeInput = {
    WithdrawalLog_Id?: IntFieldUpdateOperationsInput | number
    Inventory_Id?: IntFieldUpdateOperationsInput | number
    Withdrawal_Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Quantity_Withdrawn?: IntFieldUpdateOperationsInput | number
    Date_Withdrawn?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkLogUpdateWithoutEmployeeInput = {
    Login_Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Logout_Time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkLogUncheckedUpdateWithoutEmployeeInput = {
    WorkLog_Id?: IntFieldUpdateOperationsInput | number
    Login_Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Logout_Time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkLogUncheckedUpdateManyWithoutEmployeeInput = {
    WorkLog_Id?: IntFieldUpdateOperationsInput | number
    Login_Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Logout_Time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}